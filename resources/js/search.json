[[{"l":"Welcome"},{"l":"Red Teaming Army","p":["This is my personal blog space. The main idea of this platform is to allow me to share my knowledge in Red Teaming and Penetration Testing. Feel free to use the file navigation in order to view the present blogposts, or use the recursive search to find something specific of your needs!","I will do my best to transfer all of my videos to blogposts in order to reach more people.","The Red Teaming Army has its Discord server available here: https://discord.gg/bgSpdheEgu","Feel free to join the Discord server, where we share knowledge and experience, while debugging problems in real time!"]},{"l":"Support","p":["All of my work on this blog space is and always will be free and publicly accessible.","If you have further appreciation for my work, you can become my Patreon ( https://www.patreon.com/Lsecqt) and get access to custom tools, private notes and Know-How, and the ability to request videos or blogs on specific topic.","Or you can just buy me a coffee ( https://www.buymeacoffee.com/lsecqt)"]}],[{"l":"Unleashing the Power of Unconstrained Delegation"},{"l":"Introduction","p":["In the world of Active Directory, a lot of attacks are based on delegation misconfigurations. Depending on the context, they may allow the attacker to laterally move across the network, achieve local / domain privilege escalation or even compromise the Domain Controller (DC).","In this blog we are diving into Unconstrained Delegation.","If you prefer watching a video instead of reading, you can find my video walkthrough on the topic here: Attacking Active Directory: Unleashing the Power of Unconstrained Delegation (youtube.com)","Do not forget to join the Red Teaming Army's Discord server where we share knowledge, experience, and debug together in real time: https://discord.gg/bgSpdheEgu","Also, if you have further appreciation for my work you can become my Patreon: Lsecqt | Creating Pentesting / Red Teaming Videos | Patreon. This helps me a lot."]},{"l":"Theory"},{"i":"what-is-delegation","l":"What is Delegation?","p":["In a nutshell, delegation is the act of granting specific user / machine / service elevated rights towards other user / machine / service. Usually such privileges are granted on computers that run various services, like MSSQL / IIS or on users with bigger administrative needs.","To better understand it, let's take the following example: A user is authenticating and operating to IIS service which is connected to a MSSQL database. When the DB backend needs to be modified the IIS server connects to it on behalf of the user, thus, the IIS service or perhaps the whole machine could be entrusted for delegation.","Another example would be to entrust sysadmins or HelpDesk users to perform operational roles (create, manage and delete) for other domain users. In this case, specific tasks in the context of the Active Directory would be delegated to specific group of people."]},{"i":"what-is-unconstrained-delegation","l":"What is Unconstrained Delegation?","p":["Normally, the delegations across the Active Directory should be strictly configured. It should explicitly map the delegated user / machine to the specific services and nothing more.","Unconstrained Delegation also known as Unrestricted Delegation is characterized with that it is NOT limited to specific service, but instead it impersonates the designed user / machine with all of its access rights and permissions across the AD context. Unrestricted Delegation is designed to save the delegated user's TGT directly into the computer's memory.","For instance, if we take the previous User -> ISS -> MSSQL example, if the same scenario was replicated with configured Unconstrained Delegation, the IIS service would obtain a valid TGT for the user connecting to it.","Any authentication towards Unconstrained Delegated machine, will effectively save the incoming user's TGT into the memory of the machine. This behavior also makes UD marked machines nice targets, since they may contain a lot of valid user's TGTs."]},{"l":"Exploitation"},{"l":"Enumeration","p":["The easiest ways to enumerate Unconstrained Delegation are via:","PowerView ( https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)","BloodHound ( https://github.com/BloodHoundAD/BloodHound)"]},{"l":"PowerView","p":["PowerView is powerfull tool designed for Active Directory enumeration. It has built-in modules for analyzing delegation permissions across domain users and machine accounts.","To find Unconstrained Delegation entities, it is enough to:","Import it","Scan for Unconstrained Delegation:","Finding machines marked for Unconstrained Delegation","The following output reveals 2 machines that have Unrestricted Delegation enabled. This means:","Any user connecting via any service on any of the mentioned machines will have his TGT saved inside the memory of the corresponding machine.","Since both of them are marked as Unrestricted Delegation, if you have access to one of them, you could most likely laterally move to any other machine if you can coerce its authentication.","Since the TGT is automatically saved to the targeted computer via any form of authentication, we can capture the TGT for the Domain Controller by performing authentication coercion."]},{"l":"BloodHound","p":["It is also possible to find computer accounts marked for Unconstrained Delegation via BloodHound. I am not going to dive deep into how BloodHound operates, but in a nutshell:","When you import the collected data from the Active Directory into BloodHound, you can use the following option for finding accounts allowed for Unconstrained Delegation:","Finding machines marked for Unconstrained Delegation with BloodHound","By default, Unconstrained Delegation is assigned to machine accounts, but in some edged cases, you may enumerate the same delegation rights to be present on specific user accounts."]},{"i":"exploitation-1","l":"Exploitation","p":["Armed with the ticket we can compromise the Domain Controller or directly perform DCSync.","As mentioned before, in its core, when machine is marked for Unconstrained Delegation, any user / machine authenticating to it, via any service, will result in its TGT stored on the authentication machine.","Capturing TGT from the Domain Controller's machine account","Confirming that the dc01$ ticket is imported","For instance, in this example, we have already compromised $Client01 machine and our target is $DC01.","If we compromise a machine marked for UD, and if we somehow force authentication from other machines / users across the network, we could effectively compromise them.","In this example, we will perform coercion via SpoolSample to trigger the authentication.","Keep in mind that coercion can be triggered via various tools such as Coercer or Petitpotam, do not limit yourself with anything specific! Different tools will work in different cases.","Keep in mind that it is super common to encounter Unconstrained Delegation flag on Domain Controllers, since this is part of their operational work and they are by default trusted! Even if they are missing the flag, they can still be compromised if authentication coercion is possible!","Keep in mind that since our compromised machine Client01$ is marked for Unconstrained Delegation, by not filtering the tickets account, you can get overwhelmed. Not filtering can be extremely useful in different scenarios, but now the target is DC01$","Let's start Rubeus in monitor mode:","Now if we go back and check the Rubeus process, we can observer that the TGT from the Domain Controller's machine account was successfully dumped and injected.","Rubeus has monitor mode support, which means it can effectively listen for incoming authentication and will automatically retrieve the TGT if it is stored!","Starting Rubeus in monitor mode","The next step is to either wait for any form of authentication or force it! This may vary depending from your context and objectives, for example, phishing attacks for SMB path spoofing can be implemented, tricking users to connect to the Unconstrained machines.","The syntax is fairly simple:","This command will also filter the results based on its originating account. In this case, to have a clean output, we are interested in the Domain Controller's machine account DC01$","Triggering the authentication from the DC to our capture server via SpoolSample","We can confirm that the ticket is injected by running:","Which will get translated to:","While there are various ways of executing this attack, I prefer doing it with Rubeus."]},{"l":"Conclusion","p":["Again we are faced against the calculation between scalability and security. Of course it is easier to just setup things to be relevant to all services, but this can come with huge risk. Let’s discuss how to mitigate it!","First of all is disabling Print Spooler service, especially if you do not need it! By disabling coercion you can reduce the risk and the chance for this attack. However, as mentioned before, this is not the only way of executing it, thus, by removing coercion misconfigurations, you can still get pwned!","Keep in mind that Print Spooler is just one service / interface that can trigger authentication, there are many, many more ways to do coercion attacks. It is recommended to disable them all, unless you have practical use for them.","While this remediation technique is doing well, my most honest recommendation is to be careful when setting things up. Try to encapsulate as much as you can, this way you make the attacker’s job harder by adding hours and hours into researching in order to try more things.","Make sure to setup delegation permissions only for specific user / machine accounts and make sure they are pointing only to specific service, user or machine account. Avoid using Unrestricted Delegation, especially on machines that are not Domain Controllers.","Delegations are elegant way of optimizing the internal network mechanisms, but should be implemented with caution. Make sure to implement delegation for and to the exact assets that needs the delegation at the first place.","Hope you enjoyed and learned something new!"]}],[{"l":"Weaponizing DLL Hijacking via DLL Proxying"},{"l":"Introduction","p":["Dynamic Link Library (DLL) is a collection of code that can be shared across multiple processes in Windows. A process imports a DLL when it needs to use functions or resources externally provided by it. For example, if a message box is displayed, the User32.dll would be imported to the running process.","DLL Hijacking is an attack, in which the intruder overwrites a specific and predefined DLL on the remote file system. When a process loads the overwritten library, a malicious code will be executed instead of the real one.","While DLL Hijacking is usually exploited for persistence, privilege escalation and lateral movement, it is a great technique for initial access, since it de-chains the download from the execution phase, which is highly suspicious behavior for EDRs (Endpoint Detection and Response).","A nice webinar on EDR evasion with DLL Hijacking can be found here: https://www.youtube.com/watch?v=CKfjLnEMfvI"]},{"l":"Theory","p":["The process of loading DLLs is automatically handled by the Windows OS. To demonstrate it let's take the following C code:","When executed, a message box will appear. If we inspect the program with Process Hacker 2 we can confirm that the user32.dll module is indeed loaded into the process.","user32.dll viewed from Process Hacker","If you replace one of the loaded DLL with a malicious one, the next time a process loads it, the malicious code inside will get executed. This is DLL Hijacking.","By default, in Windows OS, when an application loads dynamic link libraries (DLLs), the operating system follows a specific search order to locate these DLLs. The search order is prioritized as:","The directory from which the application is loaded: The system looks for DLLs in the same directory as the executable file of the application.","The current working directory: If the DLL is not found in the application's directory, the system searches the current working directory. However, be cautious with relying on the current working directory, as it can change during the execution of the program.","Windows System directories: If the DLL is not found in the application's directory or the current working directory, the system searches the directories listed in the system's PATH environment variable. This includes standard system directories like C:\\Windows\\System32.","Windows directories: If the DLL is not found in the aforementioned locations, the system searches the Windows directory.","Directories listed in the PATH environment variable: If the DLL is not found in any of the previous locations, the system searches the directories listed in the PATH environment variable.","This search priority is often abused for DLL Hijacking attacks, since a lot of applications will initially request a DLL from a folder where the user has write access rights over.","When developing an application, it is important to use full paths for the needed modules in order to avoid hijacking vulnerabilities."]},{"l":"Classical DLL Hijacking","p":["By \"Classical DLL Hijacking\" I mean the exploitation of DLL Hijacking vulnerability just for demonstrative purposes (a.k.a not caring about evasion, you just want to prove that the application is vulnerable).","During this blogpost I am using DVTA for my testing environment.","Finding a DLL Hijacking vulnerability is as simple as scanning different processes for their module imports, and overwriting a module if you have write access to the path on the filesystem where it is missing or loaded.","This behavior can be easily analyzed with tools like Process Monitor. If you specify the following filters, ProcMon will scan the defined process for all DLL imports.","Filtering DVTA process and all DLL imports","After the filters are applied it is recommended to restart the application for maximum coverage. Eventually, after watching the process activity you should come up to something like this:","DVTA cannot find C:\\Users\\lsec\\Desktop\\DVTA\\DVTA\\bin\\Release\\profapi.dll","This is a perfect candidate for DLL Hijacking attack, since the DVTA application is trying to load profapi.dll within my user's folder.","For generating a sample DLL, we can use either custom made one (recommended), or a msfvenom one. For the sake of the demo, I created the following custom DLL, to spawn \"calc.exe\" process.","DLL's entry point is called \"DLLMain\" and it executes code via various conditions on how the DLL is being called. When a process reads a function from the DLL it generally uses \"DLL_PROCESS_ATTACH\". We will store our custom code there! While this sample POC is designed to just spawn calc.exe, in real scenario you want your payload execution logic here!","The same behavior can be replicated with msfvenom:","After the DLL is generated, it is enough to just transfer it over the directory from where the application is trying to load it, and it is done. When the application is restarted and the DLL is re-imported, the payload behind will get executed.","Spawning calc.exe after placing profapi.dll and restarting the application","During the \"Classical DLL Hijacking\" attack, the targeted application will most likely stop working after the custom DLL is executed! This is because the application requires specific functions from the imported DLL and our custom one is lacking them."]},{"l":"DLL Proxying","p":["Additionally, the payload execution should not be handled poorly, if the payload execution thread corrupts the process, even though the exported functions are present, the application could still timeout.","After combining the pieces I created the following POC:","After executing the command, make sure to restart the targeted binary, and then terminate Spartacus by pressing enter. When stopped, it will generate similar output: Spartacus automatically using ProcMon to filter Hijackable DLLs","After performing DLL Hijacking with the compiled DLL, the binary executes as normal, while the shell callback is present. Application is running as expected","AV / EDR Evasion","DLL Proxying is when you embed the exported functions from the original DLL into your malicious one. This way when the DLL is hijacked and loaded, the malicious payload will get executed in parallel with the intended and needed exported functions.","From the output, Spartacus founds which DLLs are hijackable and forwardable, exported their functions and generated a C++ template for the DLLs.","I already have a video on DLL Proxying, so if you prefer watching instead of reading, feel welcomed to my channel:","In a DLL, an exported function is a function that is made available for other applications or DLLs to use. When a function is exported, it means that it is exposed and can be called by external programs. Exported functions could serve as entry points for other software components to utilize the functionality provided by the DLL.","In this example it is clear that the previously exploited profapi.dll is not a good match, since Spartacus cannot export its functions. However, CRYPTSP.dll looks like a better option.","No matter in which scenario the DLL Hijacking is needed, it is important to not break the application / environment of the victim. No matter how evasive your payloads are, if the client software is corrupted, it could easily lead to internal escalation.","Now let's tweek the malicious template from Spartacus! I created Offensive CPP repository, its idea is to host offensive C/C++ independent snippets, which can be used in various scenarios. Let's copy some shellcode execution code. During the demo, I am using the FileMap snippet.","Persistence","Privilege Escalation","Receiving the reverse shell","Since the \"Classical DLL Hijacking\" is super simple to perform, it is also extremely ineffective in real engagements. In order to weaponize this attack, it is important to understand \"why\".","Spartacus requires ProcMon to be installed.","Spartacus will automatically engage with ProcMon, setup filters and find DLL hijackable binaries. After finding such, it will try to export all the functions it needs from the mentioned DLL.","The application block is generally caused by 2 factors:","The C++ template for CRYPTSP.dll looks like this in my example:","The last step is to generate a shellcode from msfvenom:","The malicious DLL is missing the functions that are needed from the application.","The payload is hijacking the thread, which can result in a timeout.","To run Spartacus, you can follow the syntax:","To solve this problem we must perform something called DLL proxying. It looks like this: https://www.ired.team/offensive-security/persistence/dll-proxying-for-persistenceDLL","Typically, the DLL Hijacking attacks are utilized for:","While each one of these topics are super complex and requires a lot of dedicated attention, we will not dive into them today. In this blog we will focus on how to weaponize the DLL Hijacking attack, so that it does not break the application runtime after the payload is executed. I am going to release more blogs on these topics in future! Stay tuned!","While this approach may sound super complex, there are tools that can export all the needed functions in C/C++ template. One such tool is called Spartacus."]},{"l":"Conclusion","p":["As mentioned before, DLL Hijacking on its own is a valid finding and often during pentests, it can be enough just to prove that the targeted application is vulnerable. However, in more complex cases, you may need to operate more stealthy.","Since the \"Classical DLL Hijacking\" is corrupting the workflow of the targeted application, this can be a huge IOC (Indicator Of Compromise). To evade being detected, before implementing any custom evasive payloads, you have to make sure that your techniques do not disrupt anyone's environment. While DLL Proxying may sound more complicated and requires additional programming skills, it is a nice way to weaponize the DLL Hijacking attack.","More on AV / EDR evasion blogs are yet to come!","Thank you for your attention, I really hope this blog was useful, if so, you can support me on:","Patreon","BuyMeACoffee","Youtube","Twitter","Github","Also make sure to join the Red Teaming Army Discord channel."]}]]